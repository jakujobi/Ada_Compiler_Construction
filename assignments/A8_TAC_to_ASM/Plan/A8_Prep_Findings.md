# Comprehensive Plan & Findings for CSC446 Assignment 8: TAC to 8086 Assembly

*(Current Date: May 2, 2025)*

## 1. Overall Goal & Context

* **Primary Task:** Translate Three-Address Code (TAC), including I/O instructions, into functional and runnable 8086 assembly code compatible with MASM/TASM and DOSBox. [A8 Req]
* **Workflow:** Assignment 8 directly follows A7. The A8 code generator (`ASMGenerator`) will take the `.tac` file produced by the A7 compiler stage as input and produce a `.asm` file as output. The process is integrated; typically, after TAC generation finishes, the code generation phase begins. [Lec 4-16]
* **Target Environment:** 8086 processor, MASM/TASM assembler, DOSBox emulator. [A8 Req], [Lec 4-9]

## 2. Input: TAC File Expectations

* **Source File:** The `.tac` file generated by your compiler after incorporating A7 and the A8 I/O extensions.
* **Format:** Line-based intermediate code. While the exact raw format can vary (e.g., whitespace delimited), it's parsed into a structure like `ParsedTACInstruction` with fields for `opcode`, `destination`, `operand1`, `operand2`. [Lec 4-14 implies alignment is helpful]
* **Expected TAC Opcodes (from TACOpcode enum):**
  * Assignment: `ASSIGN` (e.g., `(ASSIGN, a, b)`, `(ASSIGN, _t1, 5)`)
  * Arithmetic: `ADD`, `SUB`, `MUL` (e.g., `(ADD, dest, op1, op2)`). Division/Modulo are typically handled if in scope.
  * Procedure Definition: `PROC_BEGIN ProcName`, `PROC_END ProcName`
  * Procedure Call: `CALL ProcName, num_params`
  * Parameter Passing: `PARAM VarValueOrAddress` (mode determined by symbol table or TAC operand properties)
  * I/O: `WRITE_STR StringLabel`, `WRITE_INT VarOrValue`, `READ_INT VarAddress`, `WRITE_NEWLINE`
  * Control Flow: `GOTO Label`, `IF_EQ_GOTO op1, op2, Label`, `IF_FALSE_GOTO cond, Label`, etc.
  * Start Directive: `PROGRAM_START ProcName`
* **Operands:** Can be global variable names, `[bp+/-Offset]` for locals/params/temps (as formatted by `ASMOperandFormatter`), immediate numeric values, string labels (`_S0`), temporary variable names (`_t1`), procedure names.
* **Prerequisites from A7:** Constant values must be substituted directly in TAC (e.g., `22` instead of `G`). [Lec 4-14], [Lec 4-25] Temporary variable names (`_tN`) should be generated and reset for each procedure. [Lec 4-14]

## 3. Output: 8086 Assembly File Structure (`.asm`)

* **Assembler Directives (Boilerplate):**

  ```assembly
  .model small  ; Memory model
  .586         ; Processor instruction set level
  .stack 100h    ; Stack size allocation
  ```

  [A8 Req], [Lec 4-7], [Lec 4-16]
* **.data Section:**

  * Defines all global variables (depth 1) using `DW ?` (Define Word, uninitialized). [A8 Req], [Lec 4-7]
  * Defines all required string literals (from `WRITE_STR` TAC). Must use `DB` (Define Byte), have unique labels (e.g., `_S0`), and be `$`-terminated for `io.asm`'s `writestr`. Example: `_S0 DB "Enter Value: $"`. [A8 Req], [Lec 4-7], [Lec 4-16]
* **.code Section:**

  * Must include the provided I/O library: `include io.asm`. [A8 Req], [Lec 4-7], [Lec 4-16]
  * Contains all translated user procedures, enclosed in `ProcName PROC` / `ProcName ENDP` blocks. [A8 Req], [Lec 4-7]
  * Contains the mandatory `main PROC` (or `start PROC`) entry point routine. [A8 Req], [Lec 4-7]
* **Main Entry Point (`main` or `start`):** Translates the `start ProcName` TAC directive.

  ```assembly
  main PROC
      mov ax, @data  ; Initialize Data Segment register (DS)
      mov ds, ax
      call UserMainProc ; Call the procedure indicated by TAC 'start' directive
      ; Standard DOS Exit sequence
      mov ah, 04ch
      mov al, 0      ; Exit code 0
      int 21h
  main ENDP
  END main ; Must match the main PROC label
  ```

  [A8 Req], [Lec 4-7], [Lec 4-16]

## 4. Required Compiler Changes (Parser, TAC Generator, Symbol Table)

* **Parser (`RDParser*.py`):**
  * Implement new parsing functions for the A8 I/O grammar (`IO_Stat`, `In_Stat`, `Out_Stat`, `Id_List`, `Write_List`). [A8 Req]
  * Integrate calls to these functions into the main statement parsing logic (e.g., within `Parse_Statement`).
  * Handle potential lookahead needed to distinguish assignment (`var := ...`) from procedure call (`proc(...)`). [Lec 4-4]
* **TAC Generator (`TACGenerator.py` / Parser Actions):**
  * Implement semantic actions within the I/O parsing functions to generate the specific intermediate TAC instructions (e.g., `READ_INT`, `WRITE_STR`, `WRITE_INT`, `WRITE_NEWLINE` from `TACOpcode` enum). [A8 Req]
  * Ensure `putln` generates the correct sequence (e.g., `WRITE_INT Var` followed by `WRITE_NEWLINE`). [A8 Req]
  * Handle string literals encountered in `put`/`putln`: assign a unique label (e.g., `_S0`), store the literal associated with the label (for `.data` generation later, often in a separate map passed to `ASMGenerator`), and use the label in the `WRITE_STR` TAC instruction.
* **Symbol Table (`SymTable.py`):**
  * **Essential Data Fields:** Must reliably store and provide access to:
    * Per Variable/Param/Temp: `Lexeme`, `depth`, `Offset`, `size`, `Type` (e.g., integer, string label reference), `isParameter` (boolean flag or similar), `mode` (for parameters).
    * Per Procedure: `Lexeme`, `SizeOfLocals` (total bytes for locals + temps, including compiler-generated temps if stack-allocated), `SizeOfParams` (total bytes for parameters).
      [Notes/Symbol Tables], [Lec 4-7], [Lec 4-4]
  * **Offset Management:** The internal offset representation used during parsing/TAC gen (e.g., 0, 2, 4...) needs to be clearly defined. The `ASMOperandFormatter` converts these into the required negative `[bp-X]` offsets for locals/temps and positive `[bp+X]` for parameters. [A8 Req], [Lec 4-14], [Lec 4-16]
  * **String Literal Storage:** Strategy involves `TACGenerator` creating a map of `string_label -> string_value` (e.g. `string_definitions_map`) which is then passed to `ASMGenerator`.
  * **MASM Reserved Word `C`:** Implement logic to detect and rename variables named `c` (e.g., to `cc`) during insertion or formatting. `ASMOperandFormatter` handles this. [Lec 4-14], [Lec 4-16]

## 5. Core Task: Assembly Generation (`ASMGenerator` Module)

* **Overall Strategy:**
  * Read the input `.tac` file line by line.
  * Parse each line to identify its components (label, opcode, operands).
  * Use a template-based translation: each TAC opcode maps to a sequence of 8086 instructions. [Lec 4-7]
  * Manage the output `.asm` file structure (sections, procedure boundaries).
  * A two-pass approach is recommended:
    * **Pass 1:** Scan TAC, identify all global variables (depth 1) and string literals (from the `string_definitions_map` provided by `TACGenerator`) to collect definitions for the `.data` section. Collect procedure names and look up their `SizeOfLocals` and `SizeOfParams` from the symbol table.
    * **Pass 2:** Generate the assembly code section by section, using the information gathered in Pass 1.
* **Operand Handling & Translation (primarily by `ASMOperandFormatter`):**
  * For each TAC operand string:
    * Look it up in the Symbol Table (if it's an identifier/temp).
    * Check its `depth` and other properties (type, is_parameter).
    * Format the assembly operand:
      * Depth 1 (Global Var): Use the name directly (e.g., `myGlobal`).
      * Depth >= 2 (Local/Param/Temp): Convert stored `Offset` to required `[bp+/-X]` format (e.g., `[bp-4]`, `[bp+6]`).
      * Immediate Numeric Value: Use the value directly (e.g., `10`).
      * String Literal Label (from `WRITE_STR`): Use `OFFSET label` (e.g., `OFFSET _S0`).
      * Procedure Name (for `CALL`): Use the name directly (e.g., `MyProc`).
* **TAC Instruction to Assembly Mapping (Conceptual Examples - actual logic in `ASMInstructionMapper` and its translators):**
  * `(ASSIGN, dest, src)`:
    * Conceptual: `mov ax, [formatted_src]; mov [formatted_dest], ax`
    * Actual logic in `asm_im_data_mov_translators.py` handles dereferencing for reference parameters and memory-to-memory avoidance.
  * `(ADD, dest, op1, op2)`:
    * Conceptual: `mov ax, [formatted_op1]; add ax, [formatted_op2]; mov [formatted_dest], ax`
    * Actual logic in `asm_im_arithmetic_translators.py` handles dereferencing for reference parameters.
  * `(MUL, dest, op1, op2)`:
    * Conceptual: `mov ax, [formatted_op1]; mov bx, [formatted_op2]; imul bx; mov [formatted_dest], ax`
    * Actual logic in `asm_im_arithmetic_translators.py` handles dereferencing.
  * `(PROC_BEGIN, Name)`:
    * `Name PROC`
    * `push bp`
    * `mov bp, sp`
    * `sub sp, SizeOfLocalsAndTemps` (Fetch `total_locals_size` from SymTable)
  * `(PROC_END, Name)`:
    * `add sp, SizeOfLocalsAndTemps` (Fetch `total_locals_size` from SymTable)
    * `pop bp`
    * `ret SizeOfParamsInBytes` (Fetch `total_params_size` from SymTable)
    * `Name ENDP`
  * `(CALL, ProcName, num_params)`: `call ProcName` (stack cleanup for params handled by `ASMInstructionMapper` after the call if needed, using `num_params`).
  * `(PARAM, VarValue)` (Pass by Value): `push [formatted_VarValue]` (or `push immediate`).
  * `(PARAM, @VarAddress)` (Pass by Reference):
      * If VarAddress is global: `push OFFSET VarAddress`
      * If VarAddress is local: `lea ax, [bp-X_for_VarAddress]; push ax`
      * If VarAddress is already a reference parameter `[bp+Y]`: `push [bp+Y]`
  * `(WRITE_STR, StringLabel)`: `mov dx, OFFSET StringLabel ; call writestr`
  * `(READ_INT, VarAddress)`: `call readint ; mov [formatted_VarAddress], bx` (**readint returns in BX!**)
  * `(WRITE_INT, VarOrValue)`: `mov ax, [formatted_VarOrValue] ; call writeint` (**writeint expects value in AX!**)
  * `(WRITE_NEWLINE)`: `call writeln`
  * `(GOTO, Label)`: `jmp Label`
  * `(IF_FALSE_GOTO, cond, Label)`: `cmp [formatted_cond], 0; je Label` (Conceptual)
  * `(PROGRAM_START, ProcName)`: Handled by generating the `call ProcName` inside the main ASM entry point (`start PROC`).
* **Register Usage Convention:** Primarily use `AX` for data manipulation/computation. Use `BX` for holding addresses for indirect memory access (`[bx]`) and for `readint` return. Use `DX` for string offsets (`writestr`). Avoid memory-to-memory operations. [A8 Req], [Lec 4-16], [Lec 4-28]

## 6. Tooling & Testing

* **Environment:** Use DOSBox with MASM (or TASM) for assembling and running `.asm` files. [A8 Req], [Lec 4-9]
* **Library:** Ensure `io.asm` is available in the working directory and included via `include io.asm`. [A8 Req]
* **Test Cases:** Use the 5 specific test scenarios described by the professor (basic ops/globals, I/O/globals, value params, reference params, potentially a null test) to verify correctness. [Lec 4-9], [Lec 4-16]
* **Incremental Testing:** Test the generator frequently as new TAC->ASM mappings are added. [Lec 4-4]

## 7. Key Resources & Examples

* `A8_TAC_to_ASM.md`: Requirements document.
* `Notes/assignment8example.md`: Core Ada->TAC->ASM example with I/O.
* `Notes/Ada_Examples.md`: Crucial examples for stack frames, parameter passing (value/OUT), assembly structure.
* `Notes/Symbol Tables.md`: Stack frame layouts, offset details.
* Lecture Transcripts (esp. April): Provide specific templates, clarifications, register usage, pass-by-reference demo.

## 8. Scope & Exclusions

* **Optimization:** No optimization is required; focus on direct, correct translation. [Lec 4-9], [Lec 4-11]
* **Complex Control Flow:** Translation of intricate jumps/loops from TAC is likely not required by the A8 tests. [Lec 4-23]
* **Type Checking:** Assume input TAC is type-correct. [Lec 4-2], [Lec 4-4]
* **Operators:** Only basic arithmetic (`+`, `-`, `*`), assignment, call, push, and I/O ops are expected based on examples. `MOD`/`REM` are explicitly excluded. [Lec 4-30]

## 9. Important Tips & Potential Pitfalls

* **Consistency:** Maintain consistent offset calculations and naming conventions.
* **`io.asm` Verification:** Double-check the register conventions. `writeint` uses `AX`. `readint` returns in `BX`. `writestr` uses `DX` and `$`-terminated strings.
* **Pass-by-Reference Details:** Implement `PARAM @VarName` translation carefully (using `OFFSET` for globals, `LEA` for locals). Dereferencing (`mov bx, [bp+N]; mov [bx], reg` or `mov reg, [bx]`) happens in assignment/arithmetic translators. `ret N` (param size in bytes) for stack cleanup. [Lec 4-28]
* **MASM `C` Keyword:** Rename variables named `c`. `ASMOperandFormatter` handles this. [Lec 4-14], [Lec 4-16]
* **Address vs. Value:** `ASMOperandFormatter` logic: `OFFSET` for global addresses/strings; `[bp+/-offset]` for stack locations; name for global values. `LEA` for local addresses.
* **Reset Counters:** Remember to reset temporary variable counters for each procedure. [Lec 4-14]
* **MASM Size Errors:** Use an intermediate register (`mov dx, literal; mov [bx], dx`) if `mov [bx], literal` causes size ambiguity. [Lec 4-28]
* **Stack Balance:** Ensure `ret N` correctly matches the total size of parameters pushed by the caller. [Lec 4-28]

---

# Assignment 8 - Prerequisite Findings

This document records findings from the initial prerequisite checks.

## 1. io.asm Register Conventions

Based on review of `Ada_Compiler_Construction/assignments/A8_TAC_to_ASM/io.asm`:

* **`readint`**: Reads an integer from the keyboard, returns the value in register **`BX`**.
* **`writeint`**: Expects the integer to be written in register **`AX`**.
* **`writestr`**: Expects the **offset** of a '$'-terminated string in register **`DX`**.
* **`writeln`**: Writes CR/LF, does not expect input in specific registers (uses AX, DX internally).

## 2. Observed TAC Format (from test7*.tac, test8*_exp.tac)

* **General:** Line-based instructions. Whitespace (tabs/spaces) separates components. Comments start with `;`.
* **Labels:** Not observed in examples, but assumed format is `Label:` at line start.
* **Common Instructions & Operand Order:**
  * Procedure Def: `proc <Name>` -> `opcode=proc`, `dest=<Name>`
  * Procedure End: `endp <Name>` -> `opcode=endp`, `dest=<Name>`
  * Assignment (Value): `<Dest> = <Source>` -> `dest=<Dest>`, `opcode==`, `op1=<Source>`
  * Assignment (Binary Op): `<Dest> = <Op1> <Op> <Op2>` -> `dest=<Dest>`, `opcode==`, `op1=<Op1>`, `op2=<Op>`, `op3=<Op2>`
  * Procedure Call: `call <Name>` -> `opcode=call`, `op1=<Name>`
  * Push (Value): `push <Operand>` -> `opcode=push`, `op1=<Operand>`
  * Push (Reference): *(Expected)* `push @<VarName>` -> `opcode=push`, `op1=@<VarName>`
  * Read Integer: *(Expected)* `rdi <Address>` -> `opcode=rdi`, `dest=<Address>`
  * Write Integer: *(Expected)* `wri <Value>` -> `opcode=wri`, `op1=<Value>`
  * Write String: *(Expected)* `wrs <Label>` -> `opcode=wrs`, `op1=<Label>`
  * Write Newline: *(Expected)* `wrln` -> `opcode=wrln`
  * Program Start: `START\tPROC\t<Name>` -> Treat as `opcode=STARTPROC`, `op1=<Name>`.
* **Operand Representation:**
  * Globals: By name (e.g., `A`, `CC`).
  * Locals/Params: **Inconsistent!** Seen as `_BP-4` (`test74.tac`) and `[bp-2]`/`[bp+6]` (`test84/85_exp.tac`). **Decision: Target `[bp+/-N]` format for parsing and generation.** The `TACGenerator` might need fixing if it produces `_BP-N`.
  * Temporaries: `_t<Number>` (e.g., `_t1`).
  * Immediates: Literal numbers (e.g., `5`, `10`).
  * String Labels: *(Expected)* `_S<Number>`.
* **Parsing Considerations:**
  * The `TACInstruction.from_tac_line` method needs robust logic to handle different numbers of operands based on the opcode.
  * Must handle the specific `START PROC Name` format.
  * Must normalize or handle the inconsistent `_BP-N` vs `[bp-N]` representation if both can occur in input TAC (ideally, fix the generator).

---
