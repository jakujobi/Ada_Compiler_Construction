# Comprehensive Plan & Findings for CSC446 Assignment 8: TAC to 8086 Assembly

*(Current Date: May 2, 2025)*

## 1. Overall Goal & Context

* **Primary Task:** Translate Three-Address Code (TAC), including I/O instructions, into functional and runnable 8086 assembly code compatible with MASM/TASM and DOSBox. [A8 Req]
* **Workflow:** Assignment 8 directly follows A7. The A8 code generator (`ASMGenerator`) will take the `.tac` file produced by the A7 compiler stage as input and produce a `.asm` file as output. The process is integrated; typically, after TAC generation finishes, the code generation phase begins. [Lec 4-16]
* **Target Environment:** 8086 processor, MASM/TASM assembler, DOSBox emulator. [A8 Req], [Lec 4-9]

## 2. Input: TAC File Expectations

* **Source File:** The `.tac` file generated by your compiler after incorporating A7 and the A8 I/O extensions.
* **Format:** Line-based intermediate code. While not explicitly defined, assume a parseable format like `label: dest = op1 op op2` or `label: op operand1, operand2, dest` or similar, likely whitespace-delimited. Consistent formatting (e.g., columns) aids parsing in A8. [Lec 4-14 implies alignment is helpful]
* **Expected TAC Opcodes:**
    * Assignment: `=` (e.g., `a = b`, `_t1 = 5`, `[bp-2] = _t1`)
    * Arithmetic: `+`, `-`, `*` (Assume only these based on examples and lecture focus. `/`, `MOD`, `REM` are likely out of scope or not tested [Lec 4-30]).
    * Procedure Definition: `proc ProcName`, `endp ProcName`
    * Procedure Call: `call ProcName`
    * Parameter Passing: `push VarValue` (by value), `push @VarAddress` (by reference)
    * I/O: `wrs StringLabel` (write string), `wri VarAddress` (write integer), `rdi VarAddress` (read integer), `wrln` (write newline)
    * Control Flow (Less likely needed based on A8 tests, but theoretically possible): `goto Label`, `if Op1 relop Op2 goto Label`, `if false Expr goto Label`
    * Start Directive: `start ProcName`
* **Operands:** Can be global variable names, `[BP+/-Offset]` for locals/params/temps, immediate numeric values, string labels (`_S0`), temporary variable names (`_t1`), procedure names.
* **Prerequisites from A7:** Constant values must be substituted directly in TAC (e.g., `22` instead of `G`). [Lec 4-14], [Lec 4-25] Temporary variable names (`_tN`) should be generated and reset for each procedure. [Lec 4-14]

## 3. Output: 8086 Assembly File Structure (`.asm`)

* **Assembler Directives (Boilerplate):**
    ```assembly
    .model small  ; Memory model
    .586         ; Processor instruction set level
    .stack 100h    ; Stack size allocation
    ```
    [A8 Req], [Lec 4-7], [Lec 4-16]
* **.data Section:**
    * Defines all global variables (depth 1) using `DW ?` (Define Word, uninitialized). [A8 Req], [Lec 4-7]
    * Defines all required string literals (from `put`/`putln`). Must use `DB` (Define Byte), have unique labels (e.g., `_S0`), and be `$`-terminated for `io.asm`'s `writestr`. Example: `_S0 DB "Enter Value: $"`. [A8 Req], [Lec 4-7], [Lec 4-16]
* **.code Section:**
    * Must include the provided I/O library: `include io.asm`. [A8 Req], [Lec 4-7], [Lec 4-16]
    * Contains all translated user procedures, enclosed in `ProcName PROC` / `ProcName ENDP` blocks. [A8 Req], [Lec 4-7]
    * Contains the mandatory `main PROC` (or `start PROC`) entry point routine. [A8 Req], [Lec 4-7]
* **Main Entry Point (`main` or `start`):** Translates the `start ProcName` TAC directive.
    ```assembly
    main PROC
        mov ax, @data  ; Initialize Data Segment register (DS)
        mov ds, ax
        call UserMainProc ; Call the procedure indicated by TAC 'start' directive
        ; Standard DOS Exit sequence
        mov ah, 04ch
        mov al, 0      ; Exit code 0
        int 21h
    main ENDP
    END main ; Must match the main PROC label
    ```
    [A8 Req], [Lec 4-7], [Lec 4-16]

## 4. Required Compiler Changes (Parser, TAC Generator, Symbol Table)

* **Parser (`RDParser*.py`):**
    * Implement new parsing functions for the A8 I/O grammar (`IO_Stat`, `In_Stat`, `Out_Stat`, `Id_List`, `Write_List`). [A8 Req]
    * Integrate calls to these functions into the main statement parsing logic (e.g., within `Parse_Statement`).
    * Handle potential lookahead needed to distinguish assignment (`var := ...`) from procedure call (`proc(...)`). [Lec 4-4]
* **TAC Generator (`TACGenerator.py` / Parser Actions):**
    * Implement semantic actions within the I/O parsing functions to generate the specific intermediate TAC instructions (`rd#`/`rdi`, `wr#`/`wrs`/`wri`, `wrln`). [A8 Req]
    * Ensure `putln` generates the correct sequence (e.g., `wri Var` followed by `wrln`). [A8 Req]
    * Handle string literals encountered in `put`/`putln`: assign a unique label (e.g., `_S0`), store the literal associated with the label (for `.data` generation later), and use the label in the `wrs` TAC instruction.
* **Symbol Table (`SymTable.py`):**
    * **Essential Data Fields:** Must reliably store and provide access to:
        * Per Variable/Param/Temp: `Lexeme`, `depth`, `Offset`, `size`, `Type` (e.g., integer, string label reference), `isParameter` (boolean flag or similar).
        * Per Procedure: `Lexeme`, `SizeOfLocals` (total bytes for locals + temps), `SizeOfParams` (total bytes for parameters).
        [Notes/Symbol Tables], [Lec 4-7], [Lec 4-4]
    * **Offset Management:** The internal offset representation used during parsing/TAC gen (e.g., 0, 2, 4...) needs to be clearly defined. The A8 generator *must* convert these into the required negative `[bp-X]` offsets for locals/temps and positive `[bp+X]` for parameters. Consider doing this conversion within the `ASMGenerator`. [A8 Req], [Lec 4-14], [Lec 4-16]
    * **String Literal Storage:** Decide on a strategy. Either add string literals to the main symbol table (Type = string_literal, store label and value) or maintain a separate string table. The `ASMGenerator` needs access to this to define the `.data` segment.
    * **MASM Reserved Word `C`:** Implement logic to detect and rename variables named `c` (e.g., to `cc`) during insertion to avoid assembly errors. [Lec 4-14], [Lec 4-16]

## 5. Core Task: Assembly Generation (`ASMGenerator` Module)

* **Overall Strategy:**
    * Read the input `.tac` file line by line.
    * Parse each line to identify its components (label, opcode, operands).
    * Use a template-based translation: each TAC opcode maps to a sequence of 8086 instructions. [Lec 4-7]
    * Manage the output `.asm` file structure (sections, procedure boundaries).
    * A two-pass approach is recommended:
        * **Pass 1:** Scan TAC, identify all global variables (depth 1) and string literals (from `wrs` operands) to collect definitions for the `.data` section. Collect procedure names and look up their `SizeOfLocals` and `SizeOfParams` from the symbol table.
        * **Pass 2:** Generate the assembly code section by section, using the information gathered in Pass 1.
* **Operand Handling & Translation:**
    * For each TAC operand:
        * Look it up in the Symbol Table (if it's an identifier/temp).
        * Check its `depth`.
        * Format the assembly operand:
            * Depth 1 (Global Var): Use the name directly (`mov ax, myGlobal`).
            * Depth >= 2 (Local/Param/Temp): Convert stored `Offset` to required `[bp+/-X]` format (`mov ax, [bp-4]`, `mov bx, [bp+6]`).
            * Immediate Numeric Value: Use the value directly (`mov ax, 10`).
            * String Literal Label (from `wrs`): Use `OFFSET label` (`mov dx, OFFSET _S0`).
            * Procedure Name (for `call`): Use the name directly (`call MyProc`).
* **TAC Instruction to Assembly Mapping (Based on Examples/Lectures):**
    * `dest = src` (`Copy`):
        ```assembly
        mov ax, src   ; Load source into AX
        mov dest, ax  ; Store AX into destination
        ```
        *(Translate `src` and `dest` operands according to depth/type)*
    * `dest = op1 + op2` (`Add`):
        ```assembly
        mov ax, op1   ; Load op1
        add ax, op2   ; Add op2
        mov dest, ax  ; Store result
        ```
    * `dest = op1 - op2` (`Sub`): (Similar to Add, use `sub ax, op2`)
    * `dest = op1 * op2` (`Mul`):
        ```assembly
        mov ax, op1   ; Load op1 into AX
        mov bx, op2   ; Load op2 into BX
        imul bx       ; DX:AX = AX * BX
        mov dest, ax  ; Store 16-bit result from AX
        ```
    * `proc Name`:
        ```assembly
        Name PROC
        push bp
        mov bp, sp
        sub sp, SizeOfLocals ; Fetch SizeOfLocals from SymTable
        ```
    * `endp Name`:
        ```assembly
        add sp, SizeOfLocals ; Fetch SizeOfLocals from SymTable
        pop bp
        ret SizeOfParams     ; Fetch SizeOfParams from SymTable
        Name ENDP
        ```
    * `call ProcName`: `call ProcName`
    * `push VarValue` (Pass by Value): `mov ax, VarValue ; push ax` (Adjust based on operand type)
    * `push @VarAddress` (Pass by Reference): `mov ax, offset VarAddress ; push ax`
    * `wrs StringLabel`: `mov dx, offset StringLabel ; call writestr`
    * `rdi VarAddress`: `call readint ; mov VarAddress, bx` (**readint returns in BX!**)
    * `wri VarAddress`: `mov dx, VarAddress ; call writeint` (**Verify register DX/AX for writeint in io.asm!**)
    * `wrln`: `call writeln`
    * `goto Label`: `jmp Label`
    * `if op1 op op2 goto Label`: (Requires comparison and conditional jump, e.g., `cmp op1, op2; je Label`) - Details in [Lec 4-23], less likely needed for A8 tests.
    * `start ProcName`: Handled by generating the `call ProcName` inside the `main PROC`.
* **Register Usage Convention:** Primarily use `AX` for data manipulation/computation. Use `BX` for holding addresses for indirect memory access (`[bx]`). Use `DX` for string offsets (`writestr`) and potentially integer values (`writeint` - verify). Avoid memory-to-memory operations. [A8 Req], [Lec 4-16], [Lec 4-28]

## 6. Tooling & Testing

* **Environment:** Use DOSBox with MASM (or TASM) for assembling and running `.asm` files. [A8 Req], [Lec 4-9]
* **Library:** Ensure `io.asm` is available in the working directory and included via `include io.asm`. [A8 Req]
* **Test Cases:** Use the 5 specific test scenarios described by the professor (basic ops/globals, I/O/globals, value params, reference params, potentially a null test) to verify correctness. [Lec 4-9], [Lec 4-16]
* **Incremental Testing:** Test the generator frequently as new TAC->ASM mappings are added. [Lec 4-4]

## 7. Key Resources & Examples

* `A8_TAC_to_ASM.md`: Requirements document.
* `Notes/assignment8example.md`: Core Ada->TAC->ASM example with I/O.
* `Notes/Ada_Examples.md`: Crucial examples for stack frames, parameter passing (value/OUT), assembly structure.
* `Notes/Symbol Tables.md`: Stack frame layouts, offset details.
* Lecture Transcripts (esp. April): Provide specific templates, clarifications, register usage, pass-by-reference demo.

## 8. Scope & Exclusions

* **Optimization:** No optimization is required; focus on direct, correct translation. [Lec 4-9], [Lec 4-11]
* **Complex Control Flow:** Translation of intricate jumps/loops from TAC is likely not required by the A8 tests. [Lec 4-23]
* **Type Checking:** Assume input TAC is type-correct. [Lec 4-2], [Lec 4-4]
* **Operators:** Only basic arithmetic (`+`, `-`, `*`), assignment, call, push, and I/O ops are expected based on examples. `MOD`/`REM` are explicitly excluded. [Lec 4-30]

## 9. Important Tips & Potential Pitfalls

* **Consistency:** Maintain consistent offset calculations and naming conventions.
* **`io.asm` Verification:** Double-check the register conventions (especially for `writeint` - AX vs DX?) in the provided `io.asm` file itself.
* **Pass-by-Reference Details:** Implement `push offset`, `mov bx, [bp+N]`, `mov [bx], reg`, and `ret N` exactly as demonstrated. [Lec 4-28]
* **MASM `C` Keyword:** Rename variables named `c`. [Lec 4-14], [Lec 4-16]
* **Address vs. Value:** Use `OFFSET` for addresses of globals/strings; use `[bp+/-offset]` for stack locations; use name for global values.
* **Reset Counters:** Remember to reset temporary variable counters for each procedure. [Lec 4-14]
* **MASM Size Errors:** Use an intermediate register (`mov dx, literal; mov [bx], dx`) if `mov [bx], literal` causes size ambiguity. [Lec 4-28]
* **Stack Balance:** Ensure `ret N` correctly matches the total size of parameters pushed by the caller. [Lec 4-28]

---