# Assignment 8: TAC to ASM - Implementation Checklist

This checklist breaks down the implementation into verifiable steps, based on the detailed planning documents. Mark items as complete as you progress.

## Phase 0: Prerequisites & Setup

* **[X] Git Branching:**

  * [X] Ensure A7 code is committed to a stable branch (`main` or `assignment-7`).
  * [X] Create and checkout a new branch: `git checkout -b A8-work`.
* **[X] Confirm A7 TAC Format:**

  * [X] Review actual `.tac` files generated by your A7 compiler.
  * [X] Document the observed format (delimiters, operand order for different opcodes) to guide `TACInstruction.from_tac_line` parsing. (See `A8_Prep_Findings.md`)
* **[X] Verify `io.asm` Conventions:**

  * [X] Locate `io.asm`.
  * [X] Open and read `io.asm`.
  * [X] Confirm `readint` returns in `BX`.
  * [X] Confirm and **record** which register `writeint` expects input in (`AX` or `DX`). -> **Verified Register:** [__AX__] *(Update this if needed after verification)*
  * [X] Confirm `writestr` expects offset in `DX`.
* **[ ] Tooling Setup:**

  * [ ] Confirm MASM/TASM is installed and accessible.
  * [ ] Confirm DOSBox is installed and operational.
  * [ ] Place `io.asm` where MASM/TASM can find it during assembly (e.g., output directory or project root).
* **[X] Update `Definitions.py`:**

  * [X] Ensure `TokenType` enum includes `GET`, `PUT`, `PUTLN`.
  * [X] Ensure `reserved_words` dictionary maps uppercase "GET", "PUT", "PUTLN" to `TokenType.GET`, `TokenType.PUT`, `TokenType.PUTLN` respectively.
  * [ ] **Verify:** Run Lexer on test Ada code with I/O keywords; check for correct `TokenType` (`GET`, `PUT`, `PUTLN` - not `ID`).
* **[X] Update `LexicalAnalyzer.py`:**

  * [X] No changes likely needed.
  * [X] **Verify:** (Covered by `Definitions.py` verification).
* **[ ] Update `SymTable.py` (CRITICAL):**

  * [ ] **Implement/Verify:** Add (if missing) `size_of_locals: int` field to procedure entries.
  * [ ] **Implement/Verify:** Add (if missing) `size_of_params: int` field to procedure entries.
  * [ ] **Implement/Verify:** Add (if missing) mechanism to store string literals (label -> `Value$`) and retrieve values.
  * [ ] **Implement/Verify:** Add (if missing) `is_parameter: bool` flag (or equivalent) to symbol entries.
  * [ ] **Verify:** Ensure stored `offset` combined with `depth` and `is_parameter` is sufficient for `[bp+/-X]` calculation later.
  * [ ] **Verify:** Write and pass **unit tests** specifically validating storage & retrieval of: proc sizes, string literals by label, and the parameter flag.
* **[ ] Update `NewSemanticAnalyzer.py`:**

  * [ ] **Implement/Verify:** Logic calculates `SizeOfLocals` (crucially, including space needed for temps identified during TAC generation) and `SizeOfParams`.
  * [ ] **Implement/Verify:** Logic stores calculated sizes into the procedure's `SymbolTable` entry.
  * [ ] **Implement/Verify:** Logic identifies string literals in `put`/`putln`, calls `SymbolTable` to store them, and gets back the label.
  * [ ] **Verify:** Run Semantic Analysis on test procedures; **inspect `SymbolTable` state/dump** to confirm correct sizes are stored and string literals are added.
* **[ ] Update `Parser` (`RDParserExtExt.py` / Mixins):**

  * [ ] **Implement:** New parsing methods for I/O grammar (`IO_Stat`, `In_Stat`, `Out_Stat`, etc.).
  * [ ] **Implement:** Integrate calls to I/O parsing methods into `Parse_Statement`.
  * [ ] **Implement:** Semantic actions in I/O methods call `TACGenerator` for `rdi`, `wrs` (using label), `wri`, `wrln`.
  * [ ] **Implement:** `CALL ProcName(Args...)` semantic action retrieves `ProcName`'s parameter **modes** from `SymbolTable`.
  * [ ] **Implement:** `CALL` semantic action signals `TACGenerator` to emit `push @Arg` for `OUT`/`IN OUT` params, `push Arg` for `IN` params.
  * [ ] **Verify:** Parse Ada code with I/O statements; check for syntax errors. Verify required `SymbolTable` lookups occur.
* **[ ] Update `TACGenerator.py`:**

  * [ ] **Implement:** New methods (`emit_read_int`, `emit_write_int`, `emit_write_string`, `emit_write_newline`).
  * [ ] **Implement/Verify:** `emit_push` (or similar) accepts argument/flag to emit `push @VarName` vs `push VarName`.
  * [ ] **Verify:** Unit test new `emit_` methods.
  * [ ] **Verify (Integration):** Run Ada -> TAC pipeline with I/O & reference params. **Inspect `.tac` output** for correct `rdi`, `wrs`, `wri`, `wrln`, and `push @Var`/`push Var`.
* **[ ] Update `Driver.py` / `JohnA8.py`:**

  * [ ] Ensure *final, populated* `SymbolTable` instance is available for later phases.

  * *Note: Adding the `ASMGenerator` call happens later (Phase 1/2).*

## Phase 1: Foundational ASM Generator Components

* **Goal:** Create basic structures for holding/parsing TAC, ready for ASM generation.
* **[ ] Implement `TACInstruction` Data Class (`src/jakadac/asm_generator/tac_instruction.py`):**
  * [ ] Define `@dataclass` with fields (`line_number`, `label`, `opcode`, `op1`, `op2`, `dest`, potentially `op3` for binary ops based on format).
  * [ ] Implement `TACInstruction.from_tac_line()` based on **confirmed A7 TAC format** (handle different operand counts, comments, `START PROC` structure).
  * [ ] **Verify:** Unit test `from_tac_line` robustly with diverse valid/invalid TAC lines matching your confirmed format.
* **[ ] Implement `TACParser` Class (`src/jakadac/asm_generator/tac_parser.py`):**
  * [ ] Implement `__init__(tac_filepath)`.
  * [ ] Implement `parse() -> List[TACInstruction]` using `TACInstruction.from_tac_line()`. Handle file I/O errors.
  * [ ] **Verify:** Unit test `TACParser.parse` with sample `.tac` files. Check returned list structure and error handling.

## Phase 2: Skeleton Generation & Data Collection

* **Goal:** Generate the basic `.asm` file structure and `.data` section.
* **[ ] Implement `DataSegmentManager` (`src/jakadac/asm_generator/data_segment_manager.py`):**
  * [ ] Implement `__init__(symbol_table)`.
  * [ ] Implement `collect_definitions(...)`: identify globals (depth 1 vars) & string labels (`_S...`) via `SymbolTable` lookups. Store unique globals & `label -> value` pairs. Handle `c`->`cc`.
  * [ ] Implement `get_data_section_asm()`: format `.data` section lines (`VarName DW ?`, `_SLabel DB "Value$",'$'`). **Ensure sorting** for consistent output.
  * [ ] **Verify:** Unit test `DataSegmentManager` with mock `SymbolTable`/Instructions. Check `.data` output format.
* **[ ] Implement `ASMOperandFormatter` (`src/jakadac/asm_generator/asm_operand_formatter.py`):**
  * [ ] Implement `__init__(symbol_table)`.
  * [ ] Implement basic `format_operand(...)`: handle immediates, handle globals (depth 1 lookup, apply `c`->`cc`).
  * [ ] **Verify:** Unit test `format_operand` for immediate and global cases.
* **[ ] Implement `ASMGenerator` (`src/jakadac/asm_generator/asm_generator.py`):**
  * [ ] Implement `__init__(tac_filepath, asm_filepath, symbol_table)`. Instantiate `TACParser`, `DataSegmentManager`, `ASMOperandFormatter`.
  * [ ] Implement `_generate_main_entry()` returning *static minimal* `main PROC`.
  * [ ] Implement `generate_asm()`: Call parser & data manager; write boilerplate, `.data`, `.code`, `include`, minimal `main`, `END main`.
  * [ ] **Modify `Driver.py` / `JohnA8.py`:** Add call to instantiate & run `ASMGenerator.generate_asm()` after TAC gen, passing paths & populated `SymbolTable`.
  * [ ] **Verify (Integration):** Run Driver on simple Ada->TAC->ASM (globals only). Check `.asm` created. Inspect boilerplate, `.data`, `include`, `main`. **Assemble `.asm` with MASM/TASM - verify no errors.**

## Phase 3: Basic Procedures & Global Assignments

* **Goal:** Translate `proc`/`endp`, `call`, and `=` involving globals/immediates.
* **[ ] Implement `ASMInstructionMapper` (`src/jakadac/asm_generator/asm_instruction_mapper.py`):**
  * [ ] Implement `__init__(symbol_table)`.
* **[ ] Implement `ASMInstructionMapper.translate_proc`:** Lookup `SizeOfLocals` from `SymbolTable`. Generate `Name PROC`, prologue (`push bp`, `mov bp, sp`, `sub sp, SizeOfLocals`).
* **[ ] Implement `ASMInstructionMapper.translate_endp`:** Lookup `SizeOfLocals`, `SizeOfParams`. Generate epilogue (`add sp, SizeOfLocals`, `pop bp`, `ret SizeOfParams`), `Name ENDP`.
* **[ ] Implement `ASMInstructionMapper.translate_assign`:** Format operands. Generate `mov ax, src`/`mov dest, ax` (or `mov dest, immediate`).
* **[ ] Implement `ASMInstructionMapper.translate_call`:** Format operand (ProcName). Generate `call ProcName`.
* **[ ] Enhance `ASMGenerator.generate_asm()`:**
  * [ ] Instantiate `ASMInstructionMapper`.
  * [ ] Modify main loop: Handle `STARTPROC` (store name), `PROC` (set context, call mapper), `ENDP` (clear context, call mapper), `=`, `CALL` (call mapper), labels (`Label:`).
  * [ ] Modify `_generate_main_entry()` to use collected `start_proc_name` & add error check.
* **[ ] Verify (Unit Tests):** Unit test `translate_proc/endp/assign/call`.
* **[ ] Verify (Integration):** Run Driver (Ada->ASM) with procedures, calls, global assignments, `START`. Inspect `.asm` for `PROC`/`ENDP`, prologues/epilogues (verify sizes!), `call`, assignments, `main`. Assemble & run (Test Case 1 equiv). Check clean execution.

## Phase 4: Locals, Temps & Arithmetic

* **Goal:** Implement `[bp+/-X]` addressing and `+`, `*` translation.
* **[ ] Enhance `ASMOperandFormatter.format_operand`:**
  * [ ] **Implement:** Full logic for depth >= 2: Retrieve `offset`, `isParameter`. Translate internal offset to `[bp+/-X]` (**Double-check calc against stack docs!**). Handle `c`->`cc`.
  * [ ] **Verify:** Unit test `format_operand` extensively for locals, params, temps (`[bp-...]`, `[bp+...]`).
* **[ ] Enhance `ASMInstructionMapper`:**
  * [ ] Implement `translate_add`: `mov ax, op1; add ax, op2; mov dest, ax`. Format operands.
  * [ ] Implement `translate_mul`: `mov ax, op1; mov bx, op2; imul bx; mov dest, ax`. Format operands.
  * [ ] Update `translate_assign` for stack variables using enhanced formatter.
  * [ ] **Verify:** Unit test `translate_add/mul`. Re-test `translate_assign` with stack vars.
* **[ ] Enhance `ASMGenerator.generate_asm()`:** Add handling for `+`, `*` opcodes (if separate from `=`).
* **[ ] Verify (Integration):** Run Driver (Ada->ASM) with locals, temps, arithmetic. Inspect `.asm` for correct `[bp...]` usage & arithmetic sequences. Assemble & Run (use I/O or debugger to check results).

## Phase 5: String Output & Literals

* **Goal:** Handle string literals and translate `wrs`, `wrln`.
* **[ ] Verify Prerequisite:** Confirm `SymbolTable` stores `Label -> Value$` pairs & `TACGenerator` emits `wrs Label`.
* **[ ] Enhance `DataSegmentManager`:** Verify `collect_definitions` retrieves strings & `get_data_section_asm` generates `Label DB "Value$",'$'`. Verify via unit tests.
* **[ ] Enhance `ASMOperandFormatter.format_operand`:** Implement/Verify translation of `_SLabel` to `OFFSET _SLabel`. Verify via unit tests.
* **[ ] Implement `ASMInstructionMapper.translate_wrs`:** Generate `mov dx, OFFSET Label; call writestr`. Verify via unit test.
* **[ ] Implement `ASMInstructionMapper.translate_wrln`:** Generate `call writeln`. Verify via unit test.
* **[ ] Enhance `ASMGenerator.generate_asm()`:** Add handling for `wrs`, `wrln`.
* **[ ] Verify (Integration):** Run Driver (Ada->ASM) with `put`/`putln` strings. Inspect `.data` & `.code`. Assemble, run, verify string/newline output.

## Phase 6: Parameter Passing (Value) & Integer Output

* **Goal:** Implement pass-by-value (`push`) and integer output (`wri`).
* **[ ] Implement `ASMInstructionMapper.translate_push`:** Format operand. Generate `mov ax, ValueOperand; push ax` (or `push Immediate`). Verify via unit test.
* **[ ] Verify `ASMInstructionMapper.translate_endp`:** Ensure `ret N` uses correct `SizeOfParams`.
* **[ ] Verify `ASMOperandFormatter.format_operand`:** Ensure correct formatting for parameters (`[bp+X]`).
* **[ ] Implement `ASMInstructionMapper.translate_wri`:** Format operand. Generate `mov REG, ValueOperand; call writeint` (using **confirmed** register). Verify via unit test.
* **[ ] Enhance `ASMGenerator.generate_asm()`:** Add handling for `push` (value) & `wri`.
* **[ ] Verify (Integration):** Run Driver (Ada->ASM) for Test Case 3 equiv. Inspect `push`, `ret N`, `[bp+X]`, `wri` translation. Assemble, run, verify param passing & integer output.

## Phase 7: Integer Input & Pass-by-Reference

* **Goal:** Implement integer input (`rdi`) and pass-by-reference (`push @`, dereferencing).
* **[ ] Implement `ASMInstructionMapper.translate_rdi`:** Format address operand. Generate `call readint; mov AddressOperand, bx`. Verify via unit test.
* **[ ] Implement `ASMInstructionMapper.translate_push_ref`:** Assume TAC `push @VarName`. Generate `mov ax, offset VarName; push ax`. (*Verify MASM `offset` works for stack vars; revisit if needed*). Verify via unit test.
* **[ ] Enhance `ASMInstructionMapper` (Dereferencing):** Modify `assign/add/mul` to handle reference params: load address `mov bx, [bp+N]`, use `[bx]` for loads/stores. **Verify via unit tests** covering ref param cases.
* **[ ] Enhance `ASMGenerator.generate_asm()`:** Add handling for `rdi` & `push @`.
* **[ ] Verify (Integration):** Run Driver (Ada->ASM) for Test Case 5 equiv. Inspect `push offset`, `ret N`, `call readint`, `mov Address, bx`, dereferencing (`mov bx, [bp+N]; ... [bx] ...`). Assemble, run, provide input, verify caller variable modified.

## Phase 8: Final Integration, Testing & Refinement

* **Goal:** Ensure end-to-end correctness against all official tests.
* **[ ] Execute Full Pipeline:** Run `python JohnA8.py test8X.ada` for all official tests.
* **[ ] Assemble & Link:** Use MASM/TASM on each generated `.asm`. Link `.exe`. **Resolve ALL errors.**
* **[ ] Run in DOSBox:** Execute each `test8X.exe`.
* **[ ] Verify Output & Behavior:** Compare actual vs expected output. Use `fc` if helpful. **Resolve ALL discrepancies.**
* **[ ] Debugging:** Use logging, debugger, manual inspection to trace errors.
* **[ ] Code Review & Cleanup:** Review clarity, correctness, PEP 8. Add comments/docstrings. Remove debug code.
* **[ ] Final Verification:** Confirm all requirements R1-R18 are met.

## Overall Considerations

* **[ ] Error Handling:** Implement robust `try...except` blocks and specific, informative custom exceptions throughout.
* **[ ] Logging:** Use `Logger.py` for DEBUG/INFO messages to trace execution and states.
