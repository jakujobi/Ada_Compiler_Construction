# Assignment 8: TAC to ASM - Implementation Checklist

This checklist breaks down the implementation into verifiable steps. It is guided by the primary planning document **A8_Refined_Recommendations.md** and the detailed design in **ASMGenerator Module Design Plan (Detailed).md**. Tasks related to updating existing compiler modules are detailed in **Updating_existing_modules_plan.md**. Mark items as complete as you progress.

## Phase 0: Prerequisites & Setup

* **[X] Git Branching:**

  * [X] Ensure A7 code is committed to a stable branch (`main` or `assignment-7`).
  * [X] Create and checkout a new branch: `git checkout -b A8-work`.
* **[V] Confirm A7 TAC Format:** (Verified via `A8_Prep_Findings.md` and `TACParser.py` capabilities)

  * [X] Review actual `.tac` files generated by your A7 compiler.
  * [X] Document the observed format (delimiters, operand order for different opcodes) to guide `TACInstruction.from_tac_line` parsing. *(Note: Parsing logic is in `TACParser._parse_line`)*
* **[V] Verify `io.asm` Conventions:** (Verified via `A8_Prep_Findings.md`)

  * [X] Locate `io.asm`.
  * [X] Open and read `io.asm`.
  * [X] Confirm `readint` returns in `BX`.

  * [V] Confirm and **record** which register `writeint` expects input in (`AX` or `DX`). -> **Verified Register:** [**AX**]

  * [X] Confirm `writestr` expects offset in `DX`.
* **[ ] Tooling Setup:**

  * [ ] Confirm MASM/TASM is installed and accessible.
  * [ ] Confirm DOSBox is installed and operational.
  * [ ] Place `io.asm` where MASM/TASM can find it during assembly (e.g., output directory or project root).
* **[V] Update `Definitions.py`:** (Verified `src/jakadac/modules/Definitions.py`)

  * [V] Ensure `TokenType` enum includes `GET`, `PUT`, `PUTLN`.
  * [V] Ensure `reserved_words` dictionary maps uppercase "GET", "PUT", "PUTLN" to `TokenType.GET`, `TokenType.PUT`, `TokenType.PUTLN` respectively.
  * [V] **Verify:** Run Lexer on test Ada code with I/O keywords; check for correct `TokenType` (`GET`, `PUT`, `PUTLN` - not `ID`). *(Covered by `Definitions.py` correctness)*
* **[V] Update `LexicalAnalyzer.py`:** (Verified by implication of `Definitions.py` correctness)

  * [X] No changes likely needed.

  * [V] **Verify:** (Covered by `Definitions.py` verification).
* **[V] Update `SymTable.py` (CRITICAL):** (Verified `src/jakadac/modules/SymTable.py`)

  * [V] **Implement/Verify:** Add (if missing) `size_of_locals: int` field to procedure entries. *(Used existing `local_size` field)*
  * [V] **Implement/Verify:** Add (if missing) `size_of_params: int` field to procedure entries. *(Added `param_size` field)*
  * [V] **Implement/Verify:** Add (if missing) mechanism to store string literals (label -> `Value$`) and retrieve values. *(Using `EntryType.CONSTANT`, label as name, value in `const_value` for symbol; `SymbolTable.add_string_literal` manages map and returns label. `DataSegmentManager` expects this if used, or `ASMGenerator` uses map directly)*
  * [V] **Implement/Verify:** Add (if missing) `is_parameter: bool` flag (or equivalent) to symbol entries. *(Using existing `EntryType.PARAMETER`)*
  * [V] **Verify:** Ensure stored `offset` combined with `depth` and `is_parameter` is sufficient for `[bp+/-X]` calculation later. *(Confirmed structure stores necessary info)*

  * [X] **Verify:** Write and pass **unit tests** specifically validating storage & retrieval of: proc sizes, string literals by label, and the parameter flag. *(Checklist note: Tests added to `test_symtable.py`, but need import resolution)*
* **[V] Update `NewSemanticAnalyzer.py`:** (Verified `src/jakadac/modules/NewSemanticAnalyzer.py`)

  * [V] **Implement/Verify:** Logic calculates `SizeOfLocals` (crucially, including space needed for temps identified during TAC generation - *Note: Currently calculates declared locals size only*) and `SizeOfParams`.
  * [V] **Implement/Verify:** Logic stores calculated sizes into the procedure's `SymbolTable` entry (using `local_size` and `param_size` fields).
  * [V] **Implement/Verify:** Logic identifies string literals in `put`/`putln`, calls `SymbolTable.add_string_literal()` to get unique label. *(Note: `SymbolTable` handles map, `TACGenerator` will get this map for ASM gen)*.

  * [X] **Verify:** Run Semantic Analysis on test procedures; **inspect `SymbolTable` state/dump** to confirm correct sizes are stored and string literals are added.
* **[V] Update `Parser` (`RDParserExtExt.py` / Mixins):** (Verified relevant parser mixins and `RDParserExtExt.py`)

  * [V] **Implement:** New parsing methods for I/O grammar (`IO_Stat`, `In_Stat`, `Out_Stat`, etc.).
  * [V] **Implement:** Integrate calls to I/O parsing methods into `Parse_Statement`.
  * [V] **Implement:** Semantic actions in I/O methods call `TACGenerator` for `rdi`, `wrs` (using label), `wri`, `wrln`.
  * [V] **Implement:** Parser/Semantic actions for string literals in `put`/`putln`: Get string value, interface with `SymbolTable.add_string_literal()` to get unique label. `TACGenerator` then builds its `string_definitions` map.
  * [V] **Implement:** `CALL ProcName(Args...)` semantic action retrieves `ProcName`'s parameter **modes** from `SymbolTable`.
  * [V] **Implement:** `CALL` semantic action signals `TACGenerator` to emit `push @Arg` for `OUT`/`IN OUT` params, `push Arg` for `IN` params (via `emitPushParam` which calls `TACGenerator.emitPush` with mode).

  * [X] **Verify:** Parse Ada code with I/O statements; check for syntax errors. Verify required `SymbolTable` lookups occur.
* **[V] Update `TACGenerator.py`:** (Verified `src/jakadac/modules/TACGenerator.py`)

  * [V] **Implement:** New methods (`emitRead`, `emitWrite`, `emit_write_string_by_label`, `emitNewLine`).
  * [V] **Implement/Verify:** `emitPush` accepts `ParameterMode` to emit `push @VarName` vs `push VarName`.
  * [V] **Implement:** Handle `START ProcName` TAC from parser (via `emitProgramStart`).
  * [V] **Implement:** Ensure `emit_write_string_by_label` correctly uses the string *label*.

  * [X] **Verify:** Unit test new `emit_` methods.
  * [X] **Verify (Integration):** Run Ada -> TAC pipeline with I/O & reference params. **Inspect `.tac` output** for correct `rdi`, `wrs`, `wri`, `wrln`, and `push @Var`/`push Var`.
* **[V] Update `Driver.py` / `JohnA8.py`:** (Verified `assignments/A8_TAC_to_ASM/JohnA8.py`)

  * [V] Ensure *final, populated* `SymbolTable` instance is available for later phases.
  * [V] Call to `ASMGenerator` and its `generate_asm` method integrated. Command line arguments for ASM output file handled. (`ASMGenerator` receives `string_literals_map` from `TACGenerator`).
  * Done

## Phase 1: Foundational ASM Generator Components

* **Goal:** Create basic structures for holding/parsing TAC, ready for ASM generation.
* **[V] Implement `TACInstruction` Data Class (`src/jakadac/modules/asm_gen/tac_instruction.py`):** (Verified)

  * [V] Define `@dataclass` with fields (`line_number`, `label`, `opcode`, `op1`, `op2`, `dest`, potentially `op3` for binary ops based on format). (Fields are in `ParsedTACInstruction`, `TACOperand`, `TACOpcode`)
  * [V] Implement `TACInstruction.from_tac_line()` based on **confirmed A7 TAC format**. *(Note: Parsing logic is implemented in `TACParser._parse_line`)*

  * [X] **Verify:** Unit test `from_tac_line` robustly with diverse valid/invalid TAC lines. *(Applies to `TACParser._parse_line`)*
* **[V] Implement `TACParser` Class (`src/jakadac/modules/asm_gen/tac_parser.py`):** (Verified)

  * [V] Implement `__init__(tac_filepath)`.
  * [V] Implement `parse() -> List[ParsedTACInstruction]` using `TACParser._parse_line()`.

  * [X] **Verify:** Unit test `TACParser.parse` with sample `.tac` files.

## Phase 2: Skeleton Generation & Data Collection

* **Goal:** Generate the basic `.asm` file structure and `.data` section.
* **[P] Implement `DataSegmentManager` (`src/jakadac/modules/asm_gen/data_segment_manager.py`):**

  * [P] Implement `__init__(symbol_table)`. *(Current `ASMGenerator` integrates data segment logic using `string_literals_map` directly. The `DataSegmentManager` class isn't directly instantiated by `ASMGenerator`'s `__init__`)*.
  * [P] Implement `collect_definitions(...)`: identify globals & string labels. Handle `c`->`cc`. *(Partially in class; `ASMGenerator._generate_data_segment` handles globals (c->cc implemented there) and uses map for strings. String collection from SymbolTable in `DataSegmentManager` class is an alternative not currently wired)*.
  * [P] Implement `get_data_section_asm()`: format `.data` section lines. **Ensure sorting**. *(In class, also in `ASMGenerator._generate_data_segment` which has sorting)*.

  * [ ] **Verify:** Unit test `DataSegmentManager`.
* **[P] Implement `ASMOperandFormatter` (`src/jakadac/modules/asm_gen/asm_operand_formatter.py`):**

  * [V] Implement `__init__(symbol_table)`. *(Class exists. `ASMInstructionMapper` instantiates this. `ASMGenerator` also has its own `get_operand_asm` but mapper uses the class version)*.
  * [V] Implement basic `format_operand(...)`: handle immediates, globals (depth 1 lookup, apply `c`->`cc`). *(Present in `ASMOperandFormatter.py`)*.

  * [ ] **Verify:** Unit test `format_operand` for immediate and global cases.
* **[P] Implement `ASMGenerator` (`src/jakadac/modules/asm_gen/asm_generator.py`):**

  * [P] Implement `__init__(tac_filepath, asm_filepath, symbol_table)`. Instantiate `TACParser`, `ASMInstructionMapper`. *(Does not instantiate `DataSegmentManager` or `ASMOperandFormatter` as distinct member objects in `__init__`; their functionality is integrated or handled differently, e.g., mapper creates its own formatter)*.
  * [V] Implement `_generate_main_entry()` returning *static minimal* `main PROC`. *(Implemented as `_generate_dos_program_shell`)*.
  * [V] Implement `generate_asm()`: Call parser & data manager (internal `_generate_data_segment`); write boilerplate, `.data`, `.code`, `include`, minimal `main`, `END main`.

  * [X] **Modify `Driver.py` / `JohnA8.py`:** (Verified in Phase 0).
  * [ ] **Verify (Integration):** Run Driver on simple Ada->TAC->ASM (globals only). Check `.asm`. Assemble.

## Phase 3: Basic Procedures & Global Assignments

* **Goal:** Translate `proc`/`endp`, `call`, and `=` involving globals/immediates.
* **[V] Implement `ASMInstructionMapper` (`src/jakadac/modules/asm_gen/asm_instruction_mapper.py`):**

  * [V] Implement `__init__(symbol_table)`. *(Also takes logger and `ASMGenerator` instance; instantiates its own `ASMOperandFormatter`)*.
* **[X] Implement `ASMInstructionMapper.translate_proc`:** *(Via `_translate_program_start` / `_translate_proc_begin` in `ProcedureTranslators` mixin)*. Lookup `SizeOfLocals`. Generate `Name PROC`, prologue.

  * [V] **Implement/Verify:** Logic calculates `SizeOfLocals` (crucially, including space needed for temps identified during TAC generation - *Note: Currently calculates declared locals size only*) and `SizeOfParams`.
  * [V] **Implement/Verify:** Logic stores calculated sizes into the procedure's `SymbolTable` entry (using `local_size` and `param_size` fields).
  * [V] **Implement/Verify:** Logic identifies string literals in `put`/`putln`, calls `SymbolTable.add_string_literal()` to get unique label. *(Note: `SymbolTable` handles map, `TACGenerator` will get this map for ASM gen)*.

  * [X] **Verify:** Run Semantic Analysis on test procedures; **inspect `SymbolTable` state/dump** to confirm correct sizes are stored and string literals are added.
* **[V] Implement `ASMInstructionMapper.translate_endp`:** *(Via `_translate_proc_end` and `_translate_return` in `ProcedureTranslators`)*. Lookup `SizeOfLocals`, `SizeOfParams`. Generate epilogue, `Name ENDP`. *(Parameter cleanup `ret N` handled by caller `ADD SP,N`)*.

  * [V] **Implement/Verify:** Logic calculates `SizeOfLocals` (crucially, including space needed for temps identified during TAC generation - *Note: Currently calculates declared locals size only*) and `SizeOfParams`.
  * [V] **Implement/Verify:** Logic stores calculated sizes into the procedure's `SymbolTable` entry (using `local_size` and `param_size` fields).
  * [V] **Implement/Verify:** Logic identifies string literals in `put`/`putln`, calls `SymbolTable.add_string_literal()` to get unique label. *(Note: `SymbolTable` handles map, `TACGenerator` will get this map for ASM gen)*.

  * [X] **Verify:** Run Semantic Analysis on test procedures; **inspect `SymbolTable` state/dump** to confirm correct sizes are stored and string literals are added.
* **[V] Implement `ASMInstructionMapper.translate_assign`:** *(Via `_translate_assign` in `DataMovTranslators`)*. Format operands. Generate `mov ax, src`/`mov dest, ax`.

  * [V] **Implement/Verify:** Logic calculates `SizeOfLocals` (crucially, including space needed for temps identified during TAC generation - *Note: Currently calculates declared locals size only*) and `SizeOfParams`.
  * [V] **Implement/Verify:** Logic stores calculated sizes into the procedure's `SymbolTable` entry (using `local_size` and `param_size` fields).
  * [V] **Implement/Verify:** Logic identifies string literals in `put`/`putln`, calls `SymbolTable.add_string_literal()` to get unique label. *(Note: `SymbolTable` handles map, `TACGenerator` will get this map for ASM gen)*.

  * [X] **Verify:** Run Semantic Analysis on test procedures; **inspect `SymbolTable` state/dump** to confirm correct sizes are stored and string literals are added.
* **[V] Implement `ASMInstructionMapper.translate_call`:** *(Via `_translate_call` in `ProcedureTranslators`)*. Format operand. Generate `call ProcName`. *(Includes caller stack cleanup `ADD SP,N`)*.

  * [V] **Implement/Verify:** Logic calculates `SizeOfLocals` (crucially, including space needed for temps identified during TAC generation - *Note: Currently calculates declared locals size only*) and `SizeOfParams`.
  * [V] **Implement/Verify:** Logic stores calculated sizes into the procedure's `SymbolTable` entry (using `local_size` and `param_size` fields).
  * [V] **Implement/Verify:** Logic identifies string literals in `put`/`putln`, calls `SymbolTable.add_string_literal()` to get unique label. *(Note: `SymbolTable` handles map, `TACGenerator` will get this map for ASM gen)*.

  * [X] **Verify:** Run Semantic Analysis on test procedures; **inspect `SymbolTable` state/dump** to confirm correct sizes are stored and string literals are added.
* **[V] Enhance `ASMGenerator.generate_asm()`:**

  * [V] Instantiate `ASMInstructionMapper`.
  * [V] Modify main loop: Handle `STARTPROC`, `PROC`, `ENDP`, `=`, `CALL`, labels.
  * [V] Modify `_generate_main_entry()` to use collected `start_proc_name`.

## Phase 4: Locals, Temps & Arithmetic

* **Goal:** Implement `[bp+/-X]` addressing and `+`, `*` translation.
* **[V] Enhance `ASMOperandFormatter.format_operand`:**

  * [V] **Implement:** Full logic for depth >= 2: Retrieve `offset`, `isParameter`. Translate internal offset to `[bp+/-X]`. Handle `c`->`cc`. *(Logic present in `ASMOperandFormatter.py`)*.

  * [X] **Verify:** Unit test `format_operand` extensively. *(Checklist note: Tests passed)*
* **[V] Enhance `ASMInstructionMapper`:**

  * [V] Implement `translate_add`: `mov ax, op1; add ax, op2; mov dest, ax`. Format operands. *(Dereferencing for reference parameters implemented in `ArithmeticTranslators`)*.
  * [V] Implement `translate_mul`: `mov ax, op1; mov bx, op2; imul bx; mov dest, ax`. Format operands. *(Dereferencing for reference parameters implemented in `ArithmeticTranslators`)*.
  * [P] Update `translate_assign` for stack variables using enhanced formatter. *(Code in `DataMovTranslators` uses formatter and handles dereferencing. Checklist note about failing tests makes this 'Partial' for full correctness)*.
  * [-] **Verify:** Unit test `translate_add/mul`. Re-test `translate_assign`. *(Checklist note: Arithmetic tests need update for pass-by-ref. Data movement tests updated but failing)*.
* **[V] Enhance `ASMGenerator.generate_asm()`:** Add handling for `+`, `*` opcodes (if separate from `=`). *(Handled via `ASMInstructionMapper` dispatch)*.

## Phase 5: String Output & Literals- Done

* **Goal:** Handle string literals and translate `wrs`, `wrln`.
* **[V] Verify Prerequisite:** Confirm `SymbolTable` stores `Label -> Value` pairs (value without `$`) & `TACGenerator` emits `wrs Label` and passes map of labels/values.

  * [V] **Implement/Verify:** Logic calculates `SizeOfLocals` (crucially, including space needed for temps identified during TAC generation - *Note: Currently calculates declared locals size only*) and `SizeOfParams`.
  * [V] **Implement/Verify:** Logic stores calculated sizes into the procedure's `SymbolTable` entry (using `local_size` and `param_size` fields).
  * [V] **Implement/Verify:** Logic identifies string literals in `put`/`putln`, calls `SymbolTable.add_string_literal()` to get unique label. *(Note: `SymbolTable` handles map, `TACGenerator` will get this map for ASM gen)*.

  * [X] **Verify:** Run Semantic Analysis on test procedures; **inspect `SymbolTable` state/dump** to confirm correct sizes are stored and string literals are added.
* **[V] Enhance `DataSegmentManager`:** Verify `collect_definitions` retrieves strings & `get_data_section_asm` generates `Label DB "Value$",'$'`. *(Functionality verified in `ASMGenerator._generate_data_segment` using the direct map, adds `$`).*

  * [V] **Implement/Verify:** Logic calculates `SizeOfLocals` (crucially, including space needed for temps identified during TAC generation - *Note: Currently calculates declared locals size only*) and `SizeOfParams`.
  * [V] **Implement/Verify:** Logic stores calculated sizes into the procedure's `SymbolTable` entry (using `local_size` and `param_size` fields).
  * [V] **Implement/Verify:** Logic retrieves strings and generates `Label DB "Value$",'$'`. *(Functionality verified in `ASMGenerator._generate_data_segment` using the direct map, adds `$`).*

  * [X] **Verify:** Run Semantic Analysis on test procedures; **inspect `SymbolTable` state/dump** to confirm correct sizes are stored and string literals are added.
* **[V] Enhance `ASMOperandFormatter.format_operand`:** Implement/Verify translation of `_SLabel` to `OFFSET _SLabel` for `WRS` context.

  * [V] **Implement/Verify:** Logic calculates `SizeOfLocals` (crucially, including space needed for temps identified during TAC generation - *Note: Currently calculates declared locals size only*) and `SizeOfParams`.
  * [V] **Implement/Verify:** Logic stores calculated sizes into the procedure's `SymbolTable` entry (using `local_size` and `param_size` fields).
  * [V] **Implement/Verify:** Logic retrieves strings and generates `Label DB "Value$",'$'`. *(Functionality verified in `ASMGenerator._generate_data_segment` using the direct map, adds `$`).*

  * [X] **Verify:** Run Semantic Analysis on test procedures; **inspect `SymbolTable` state/dump** to confirm correct sizes are stored and string literals are added.
* **[V] Implement `ASMInstructionMapper.translate_wrs`:** *(Via `_translate_write_str` in `IOTranslators`)*. Generate `mov dx, OFFSET Label; call writestr`.

  * [V] **Implement/Verify:** Logic calculates `SizeOfLocals` (crucially, including space needed for temps identified during TAC generation - *Note: Currently calculates declared locals size only*) and `SizeOfParams`.
  * [V] **Implement/Verify:** Logic stores calculated sizes into the procedure's `SymbolTable` entry (using `local_size` and `param_size` fields).
  * [V] **Implement/Verify:** Logic retrieves strings and generates `Label DB "Value$",'$'`. *(Functionality verified in `ASMGenerator._generate_data_segment` using the direct map, adds `$`).*

  * [X] **Verify:** Run Semantic Analysis on test procedures; **inspect `SymbolTable` state/dump** to confirm correct sizes are stored and string literals are added.
* **[V] Implement `ASMInstructionMapper.translate_wrln`:** *(Via `_translate_write_newline` in `IOTranslators`)*. Generate `call writeln`.

  * [V] **Implement/Verify:** Logic calculates `SizeOfLocals` (crucially, including space needed for temps identified during TAC generation - *Note: Currently calculates declared locals size only*) and `SizeOfParams`.
  * [V] **Implement/Verify:** Logic stores calculated sizes into the procedure's `SymbolTable` entry (using `local_size` and `param_size` fields).
  * [V] **Implement/Verify:** Logic retrieves strings and generates `Label DB "Value$",'$'`. *(Functionality verified in `ASMGenerator._generate_data_segment` using the direct map, adds `$`).*

  * [X] **Verify:** Run Semantic Analysis on test procedures; **inspect `SymbolTable` state/dump** to confirm correct sizes are stored and string literals are added.
* **[V] Enhance `ASMGenerator.generate_asm()`:** Add handling for `wrs`, `wrln`. *(Handled via `ASMInstructionMapper` dispatch)*.

## Phase 6: Parameter Passing (Value) & Integer Output - Done

* **Goal:** Implement pass-by-value (`push`) and integer output (`wri`).
* **[V] Implement `ASMInstructionMapper.translate_push`:** *(Via `_translate_push` in `ProcedureTranslators`)*. Format operand. Generate `mov ax, ValueOperand; push ax` (or `push Immediate`). *(Handles value push correctly)*.

  * [V] **Implement/Verify:** Logic calculates `SizeOfLocals` (crucially, including space needed for temps identified during TAC generation - *Note: Currently calculates declared locals size only*) and `SizeOfParams`.
  * [V] **Implement/Verify:** Logic stores calculated sizes into the procedure's `SymbolTable` entry (using `local_size` and `param_size` fields).
  * [V] **Implement/Verify:** Logic retrieves strings and generates `Label DB "Value$",'$'`. *(Functionality verified in `ASMGenerator._generate_data_segment` using the direct map, adds `$`).*

  * [X] **Verify:** Run Semantic Analysis on test procedures; **inspect `SymbolTable` state/dump** to confirm correct sizes are stored and string literals are added.
* **[V] Verify `ASMInstructionMapper.translate_endp`:** Ensure `ret N` uses correct `SizeOfParams`. *(Convention is caller cleanup via `ADD SP,N` after `CALL`; `ENDP` uses simple `RET` via `_translate_return`. Consistent.)*

  * [V] **Implement/Verify:** Logic calculates `SizeOfLocals` (crucially, including space needed for temps identified during TAC generation - *Note: Currently calculates declared locals size only*) and `SizeOfParams`.
  * [V] **Implement/Verify:** Logic stores calculated sizes into the procedure's `SymbolTable` entry (using `local_size` and `param_size` fields).
  * [V] **Implement/Verify:** Logic retrieves strings and generates `Label DB "Value$",'$'`. *(Functionality verified in `ASMGenerator._generate_data_segment` using the direct map, adds `$`).*

  * [X] **Verify:** Run Semantic Analysis on test procedures; **inspect `SymbolTable` state/dump** to confirm correct sizes are stored and string literals are added.
* **[V] Verify `ASMOperandFormatter.format_operand`:** Ensure correct formatting for parameters (`[bp+X]`). *(Verified)*.

  * [V] **Implement/Verify:** Logic calculates `SizeOfLocals` (crucially, including space needed for temps identified during TAC generation - *Note: Currently calculates declared locals size only*) and `SizeOfParams`.
  * [V] **Implement/Verify:** Logic stores calculated sizes into the procedure's `SymbolTable` entry (using `local_size` and `param_size` fields).
  * [V] **Implement/Verify:** Logic retrieves strings and generates `Label DB "Value$",'$'`. *(Functionality verified in `ASMGenerator._generate_data_segment` using the direct map, adds `$`).*

  * [X] **Verify:** Run Semantic Analysis on test procedures; **inspect `SymbolTable` state/dump** to confirm correct sizes are stored and string literals are added.
* **[V] Implement `ASMInstructionMapper.translate_wri`:** *(Via `_translate_write_int` in `IOTranslators`)*. Format operand. Generate `mov AX, ValueOperand; call writeint`.

  * [V] **Implement/Verify:** Logic calculates `SizeOfLocals` (crucially, including space needed for temps identified during TAC generation - *Note: Currently calculates declared locals size only*) and `SizeOfParams`.
  * [V] **Implement/Verify:** Logic stores calculated sizes into the procedure's `SymbolTable` entry (using `local_size` and `param_size` fields).
  * [V] **Implement/Verify:** Logic retrieves strings and generates `Label DB "Value$",'$'`. *(Functionality verified in `ASMGenerator._generate_data_segment` using the direct map, adds `$`).*

  * [X] **Verify:** Run Semantic Analysis on test procedures; **inspect `SymbolTable` state/dump** to confirm correct sizes are stored and string literals are added.
* **[V] Enhance `ASMGenerator.generate_asm()`:** Add handling for `push` (value) & `wri`. *(Handled via `ASMInstructionMapper` dispatch)*.

## Phase 7: Integer Input & Pass-by-Reference

* **Goal:** Implement integer input (`rdi`) and pass-by-reference (`push @`, dereferencing).
* **[BUG] Implement `ASMInstructionMapper.translate_rdi`:** *(Via `_translate_read_int` in `IOTranslators`)*. Format address operand. Generate `call readint; mov AddressOperand, bx`. *(Current code uses `AX` for result of `READINT`, should be `BX`.)*

  * [V] **Implement/Verify:** Logic calculates `SizeOfLocals` (crucially, including space needed for temps identified during TAC generation - *Note: Currently calculates declared locals size only*) and `SizeOfParams`.
  * [V] **Implement/Verify:** Logic stores calculated sizes into the procedure's `SymbolTable` entry (using `local_size` and `param_size` fields).
  * [V] **Implement/Verify:** Logic retrieves strings and generates `Label DB "Value$",'$'`. *(Functionality verified in `ASMGenerator._generate_data_segment` using the direct map, adds `$`).*

  * [X] **Verify:** Run Semantic Analysis on test procedures; **inspect `SymbolTable` state/dump** to confirm correct sizes are stored and string literals are added.
* **[V] Implement `ASMInstructionMapper.translate_push_ref`:** Assume TAC `push @VarName`. *(Handled by `_translate_push` in `ProcedureTranslators` when `is_address_of` is true; generates `LEA AX, [bp-X]; PUSH AX` or `PUSH OFFSET Global`)*.

  * [V] **Implement/Verify:** Logic calculates `SizeOfLocals` (crucially, including space needed for temps identified during TAC generation - *Note: Currently calculates declared locals size only*) and `SizeOfParams`.
  * [V] **Implement/Verify:** Logic stores calculated sizes into the procedure's `SymbolTable` entry (using `local_size` and `param_size` fields).
  * [V] **Implement/Verify:** Logic retrieves strings and generates `Label DB "Value$",'$'`. *(Functionality verified in `ASMGenerator._generate_data_segment` using the direct map, adds `$`).*

  * [X] **Verify:** Run Semantic Analysis on test procedures; **inspect `SymbolTable` state/dump** to confirm correct sizes are stored and string literals are added.
* **[P] Enhance `ASMInstructionMapper` (Dereferencing):** Modify `assign/add/mul` to handle reference params. *(Code for dereferencing exists in `DataMovTranslators` and `ArithmeticTranslators`. Checklist note about failing tests makes this 'Partial' for full correctness)*.

  * [V] **Implement/Verify:** Logic calculates `SizeOfLocals` (crucially, including space needed for temps identified during TAC generation - *Note: Currently calculates declared locals size only*) and `SizeOfParams`.
  * [V] **Implement/Verify:** Logic stores calculated sizes into the procedure's `SymbolTable` entry (using `local_size` and `param_size` fields).
  * [V] **Implement/Verify:** Logic retrieves strings and generates `Label DB "Value$",'$'`. *(Functionality verified in `ASMGenerator._generate_data_segment` using the direct map, adds `$`).*

  * [X] **Verify:** Run Semantic Analysis on test procedures; **inspect `SymbolTable` state/dump** to confirm correct sizes are stored and string literals are added.
* **[V] Enhance `ASMGenerator.generate_asm()`:** Add handling for `rdi` & `push @`. *(Handled via `ASMInstructionMapper` dispatch)*.

## Phase 8: Final Integration, Testing & Refinement

* **Goal:** Ensure end-to-end correctness against all official tests.
* **[ ] Execute Full Pipeline:** Run `python JohnA8.py test8X.ada` for all official tests.
* **[ ] Assemble & Link:** Use MASM/TASM on each generated `.asm`. Link `.exe`. **Resolve ALL errors.**
* **[ ] Run in DOSBox:** Execute each `test8X.exe`.
* **[ ] Verify Output & Behavior:** Compare actual vs expected output. Use `fc` if helpful. **Resolve ALL discrepancies.**
* **[ ] Debugging:** Use logging, debugger, manual inspection to trace errors.
* **[ ] Code Review & Cleanup:** Review clarity, correctness, PEP 8. Add comments/docstrings. Remove debug code.
* **[ ] Final Verification:** Confirm all requirements R1-R18 are met.

## Overall Considerations

* **[P] Error Handling:** Implement robust `try...except` blocks and specific, informative custom exceptions throughout. *(Basic logging of errors seen, custom exceptions in `SymTable`, but overall strategy not fully audited)*.
* **[V] Logging:** Use `Logger.py` for DEBUG/INFO messages to trace execution and states. *(Logger used extensively)*.
