## 1. Project Overview
- **Objective:**  
    Develop an Ada compiler (for a subset of Ada) with the following stages:
    - **Lexical Analysis:** Tokenizes the source code.
    - **Syntax Analysis (RDParser):** Builds a parse tree and validates syntax.
    - **Semantic Analysis (Separate Pass):** Traverses and annotates the parse tree to perform semantic actions, updates the symbol table, and checks for type compatibility.
    - **Driver Program (`JohnA5.py`):** Coordinates the process, handles user input (including error handling options), and outputs results using ASCII-formatted tables.
- **Key Modules:**
    - **LexicalAnalyzer. Py:** Converts source code into tokens.
    - **RDParser. Py:** Builds the parse tree.
    - **Semantic_Analyzer. Py:** Processes the parse tree to perform semantic analysis, symbol table management, and type compatibility checks.
    - **AdaSymbolTable. Py:** Manages symbols (variables, constants, procedures) using a hash table with chaining.
    - **Logger. Py:** Logs errors, debug, and informational messages.
    - **JohnA 5. Py (Driver):** Manages overall compilation flow, input, configuration, and formatted output.
---
## 2. High-Level Workflow
1. **Input & Configuration (JohnA5.py):**
    - Read the source file.
    - Prompt the user to activate `stop_on_error` (default is **false**; pressing Enter leaves it deactivated).
        
2. **Lexical Analysis:**
    - Process the source code using `LexicalAnalyzer.py` to produce a token list.
    - Log tokenization steps and report any lexical errors.
3. **Syntax Analysis (RDParser):**
    - Pass tokens to `RDParser.py` to build a parse tree.
    - **Enhancements:**
        - Modify the parse tree nodes so that every nonterminal node carries a `semantic_info` dictionary.
        - Embed additional fields directly in each node (e.g., computed type, offset) to support semantic actions.
    - Log syntactic errors using Logger.
    - Optionally display the parse tree.
        
4. **Semantic Analysis (Separate Pass):**
    - Invoke `Semantic_Analyzer.py` with the enhanced parse tree and the current symbol table.
    - Traverse the parse tree to perform:
        - **Symbol Table Updates:**
            - Insert constants, variables, and procedures.
            - Compute and assign offsets.
            - Insert procedure parameters.
        - **Duplicate Declaration Checks:**
            - Use `AdaSymbolTable.lookup(lexeme, depth)` to detect duplicates.
        - **Type Compatibility Checks:**
            - Annotate parse tree nodes (using their `semantic_info` dictionary) with computed type information.
            - Verify that operations (e.g., assignments, expressions) are type compatible.
            - Check that procedure parameters match the expected types.
    - Log semantic errors and, if `stop_on_error` is true, halt on the first error encountered.
        
5. **Reporting & Output:**
    - Use ASCII tables to display:
        - The final symbol table (using `AdaSymbolTable.writeTable`).
        - A summary of syntactic and semantic errors.
    - Display essential information to the screen and log all details to the file via Logger.
    - Optionally, print the annotated parse tree.
        

---
## 3. Detailed Module Responsibilities
### 3.1. Lexical Analyzer
- **Function:**  
    Tokenizes source code based on regex patterns.
- **Output:**  
    A list of tokens with attributes (token type, lexeme, line, column, etc.).
- **Logging:**  
    Reports lexical errors via Logger.

### 3.2. RDParser
- **Function:**
    - Parses tokens to generate a parse tree.
    - Validates syntax against Ada grammar.
- **Enhancements for Parse Tree:**
    - **Semantic Annotations:**
        - Extend each nonterminal `ParseTreeNode` to carry a `semantic_info` dictionary.
        - Include additional fields (such as computed type and offset) as part of the node.
        - For example, after processing a variable declaration, store its computed type and memory offset in the node’s fields.
    - **Output:**
        - A parse tree that is enriched with semantic context and ready for the semantic analysis pass.
- **Error Handling:**
    - Reports syntactic errors using Logger.
### 3.3. Semantic_Analyzer (Separate Module)

- **Function:**
    - Traverses the enhanced parse tree generated by RDParser.
    - Performs semantic actions:
        - **Symbol Table Management:**
            - Insert constants, variables, and procedures into `AdaSymbolTable`.
            - Compute memory offsets for variables (first variable at a scope starts at 0; subsequent ones increment based on size).
            - Process procedure formal parameters.
        - **Duplicate Declarations:**
            - Check for duplicates via `AdaSymbolTable.lookup`.
            - Log and handle duplicate declaration errors.
        - **Type Compatibility:**
            - For each node (e.g., assignment, operation, procedure call), check that types (stored in `semantic_info`) are compatible.
            - Report mismatches (e.g., assigning a float to an integer variable) using Logger.
    - **Error Handling:**
        - Use a `stop_on_error` flag (default false) to determine whether to halt on the first semantic error or continue processing.
- **Output:**
    - Updates the symbol table.
    - Produces an annotated parse tree with semantic details.
    - Generates detailed error logs.

### 3.4. AdaSymbolTable

- **Function:**
    - Manages symbols via a hash table with chaining.
    - Supports insertion, lookup, deletion, and reporting of symbol entries.
- **Usage:**
    - Invoked by Semantic_Analyzer to update and maintain symbols.
- **Output Formatting:**
    - Use ASCII tables (via `writeTable`) for readability when displaying the symbol table.

### 3.5. Logger

- **Function:**
    - Logs all error, debug, and informational messages.
    - Writes logs to a file and displays essential information on the screen.
- **Integration:**
    - Used across LexicalAnalyzer, RDParser, Semantic_Analyzer, and JohnA5.py.

### 3.6. JohnA5.py (Driver Program)

- **Responsibilities:**
    1. **Input Handling:**
        - Read the Ada source file.
        - Prompt the user regarding the `stop_on_error` option:
            - Example prompt:  
                `"Activate stop on error? Press 'y' to activate, or just hit Enter to leave it deactivated:"`
    2. **Process Coordination:**
        - Instantiate and invoke LexicalAnalyzer to tokenize the source.
        - Pass tokens to RDParser to generate the enhanced parse tree.
        - Invoke Semantic_Analyzer with the enhanced parse tree, symbol table, and `stop_on_error` flag.
    3. **Reporting:**
        - Display the final symbol table and error summary using well-formatted ASCII tables.
        - Optionally display the annotated parse tree.
        - Ensure all output details are also logged via Logger.

---

## 4. Type Compatibility Checks

- **Plan for Type Checking:**
    - **Annotation:**
        - During semantic analysis, annotate relevant parse tree nodes (within their `semantic_info` dictionary) with a computed type (e.g., integer, float, or char).
            
    - **Operations:**
        - For assignments and expressions, verify that the left-hand side type is compatible with the right-hand side.
        - For procedure calls, ensure that actual argument types match the formal parameter types.
        - Include checks for arithmetic operations and apply implicit conversions (e.g., integer to float) if allowed.
            
    - **Error Reporting:**
        - Log any type mismatches with precise location (line and column) using Logger.
            
    - **Integration:**
        - Extend Semantic_Analyzer functions to include helper routines for comparing types and validating compatibility.
            

---

## 5. ASCII Output Formatting

- **Symbol Table Display:**
    - Use ASCII table formatting to list symbol entries, for example:
    ```
    +------------+----------+-------+------+--------+
    | Lexeme     | Type     | Scope | Size | Offset |
    +------------+----------+-------+------+--------+
    | counter    | VARIABLE | 1     | 4    | 0      |
    | PI         | CONSTANT | 1     | -    | -      |
    +------------+----------+-------+------+--------+
    ```
    
- **Error Summary:**
    - Use a simple ASCII table to list errors:
    ```
    +----------------------+----------------------+---------------------+
    | Line, Column         | Error Type           | Message             |
    +----------------------+----------------------+---------------------+
    | 12, 15               | Semantic             | Duplicate 'num'     |
    | 20, 5                | Type Compatibility   | Float assigned to int|
    +----------------------+----------------------+---------------------+
    ```
    
- **Parse Tree Display:**
    - If desired, print the annotated parse tree using ASCII connectors (e.g., ├──, └──) for a clear hierarchical view.
    

---
## 6. Integration Sequence in JohnA5.py

1. **File Input & User Prompt:**
    - Read the Ada source file.
    - Prompt the user regarding `stop_on_error` (default false if Enter is pressed).
        
2. **Lexical Analysis:**
    - Tokenize input with LexicalAnalyzer.
    - Log and display a tokenization summary.
3. **Syntax Analysis (RDParser):**
    - Build the enhanced parse tree from tokens.
    - Optionally print the parse tree (with `semantic_info` placeholders).
    - Log syntactic errors.
        
4. **Semantic Analysis (Separate Pass):**
    - Process the enhanced parse tree with Semantic_Analyzer.
    - Update the symbol table with declarations.
    - Perform duplicate checks and type compatibility tests.
    - Annotate the parse tree nodes with computed semantic info.
    - Log semantic errors.
    - If `stop_on_error` is true, halt on the first error encountered.
5. **Reporting & Output:**
    - Print well-formatted ASCII tables for the final symbol table and error summary.
    - Optionally display the annotated parse tree.
    - Log all outputs to the file via Logger.
        

---

