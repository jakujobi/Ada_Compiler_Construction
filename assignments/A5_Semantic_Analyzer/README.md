# Ada Compiler Construction - Assignment 5: Semantic Analyzer

## Overview

This project implements a compiler for a subset of the Ada programming language, focusing on the integration of lexical analysis, syntax analysis, and semantic analysis phases. The main component, `JohnA5.py`, orchestrates these phases and ensures they work together seamlessly.

## Components

### 1. JohnA5.py

The main driver program that coordinates all compilation phases:

- **Lexical Analysis**: Tokenizes the source code using the LexicalAnalyzer module
- **Syntax Analysis**: Parses the tokens into a parse tree using the RDParser module
- **Semantic Analysis**: Analyzes the parse tree for semantic correctness using the SemanticAnalyzer module

### 2. Lexical Analyzer

Responsible for breaking down the source code into tokens:

- Recognizes identifiers, keywords, operators, and literals
- Handles comments and whitespace
- Reports lexical errors

### 3. RDParser

A recursive descent parser that verifies the syntactic correctness of the program:

- Implements the grammar for a subset of Ada
- Constructs a parse tree for valid programs
- Provides error recovery mechanisms
- Supports configurable error handling

### 4. SemanticAnalyzer

Performs semantic analysis on the parse tree:

- Builds and manages the symbol table
- Verifies type compatibility
- Checks for undeclared or multiply-declared identifiers
- Tracks variable scopes and procedure parameters
- Reports semantic errors

### 5. AdaSymbolTable

Implements a symbol table for the Ada compiler:

- Uses a hash table with chaining for collision resolution
- Supports lexical scoping through depth parameters
- Provides operations for inserting, looking up, and deleting entries
- Tracks variable types, sizes, and offsets

## Grammar

The compiler supports a subset of Ada with the following grammar:

```
Prog -> procedure idt Args is
        DeclarativePart
        Procedures
        begin
        SeqOfStatements
        end idt;

DeclarativePart -> IdentifierList : TypeMark ; DeclarativePart | ε

IdentifierList -> idt | IdentifierList , idt

TypeMark -> integert | realt | chart | const assignop Value 

Value -> NumericalLiteral

Procedures -> Prog Procedures | ε

Args -> ( ArgList ) | ε

ArgList -> Mode IdentifierList : TypeMark MoreArgs

MoreArgs -> ; ArgList | ε

Mode -> in | out | inout | ε

SeqOfStatements -> ε
```

## Features

1. **Modular Design**: Each component is designed to work independently and can be tested separately.
2. **Detailed Error Reporting**: Comprehensive error messages with line and column information.
3. **Parse Tree Visualization**: ASCII art representation of the parse tree for debugging.
4. **Symbol Table Management**: Efficient symbol table implementation with support for different entry types.
5. **Semantic Checks**:

   - Variable declarations and usage
   - Type checking
   - Scope management
   - Procedure parameter validation
6. **Compilation Summary**: Provides a summary of all errors found during compilation.

## Usage

To compile an Ada program:

```bash
python JohnA5.py <input_file>
```

### Command Line Arguments

- `<input_file>`: Path to the Ada source code file

### Example

```bash
python JohnA5.py test_program.ada
```

## Implementation Details

### Semantic Analysis Process

1. **Symbol Table Construction**:

   - The symbol table is initialized with a default size of 211 entries
   - Each entry stores information about identifiers including type, scope, and memory allocation
2. **Parse Tree Traversal**:

   - The semantic analyzer walks the parse tree in a depth-first manner
   - For each node, appropriate semantic actions are performed based on the grammar production
3. **Semantic Checks**:

   - Variables must be declared before use
   - No duplicate declarations at the same scope level
   - Type compatibility in assignments and expressions
   - Proper procedure parameter usage
4. **Error Handling**:

   - Semantic errors are collected and reported
   - The analyzer can be configured to stop on the first error or continue analysis

### Integration Challenges

1. **Token Normalization**: Ensuring consistent token representation between lexical and syntax phases.
2. **Parse Tree Compatibility**: Making the parse tree generated by RDParser compatible with the SemanticAnalyzer's expectations.
3. **Error Propagation**: Coordinating error handling across all compilation phases.

## Author

John Akujobi
GitHub: https://github.com/jakujobi/Ada_Compiler_Construction
