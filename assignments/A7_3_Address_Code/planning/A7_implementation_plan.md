# Assignment 7: Three Address Code Generation - Implementation Plan

## Goal

Modify the existing Ada parser (`RDParserExtended.py`) to generate Three-Address Code (TAC) according to the specification, outputting to a `.tac` file.

---

## Core Requirements Recap

- **Output File:** `<input_base>.tac`
- **Variables:** Depth 1 -> name; Depth > 1 -> `_BP+/-offset`.
- **Offsets:**
  - Locals: Negative (`_BP-2`, `_BP-4`, ...), size-dependent.
  - Params: Positive (`_BP+4`, `_BP+6`, ...), Pascal L->R push order (first param has largest offset).
  - Base: `_BP` points to Old BP location on stack.
- **Constants:** Substitute values directly.
- **Structure:** `proc <name>` / `endp <name>`, final `start <outermost_proc_name>`.
- **Procedure Calls:** `push <place>` (value) or `push @<place>` (reference), followed by `call <procName>`.
- **Temporaries:** `_t1`, `_t2`, ... reset per procedure.


## Phase 1: Symbol Table & Offset Calculation (`SymTable.py`, `RDParserExtended.py`)

1. **`SymTable.py` - `Symbol` Class:**

   * Define byte sizes for `VarType` (e.g., INT=2, FLOAT=4). Store in `Symbol.size`.
   * Confirm `Symbol.offset` field exists.
   * Confirm `Symbol.param_modes` (dict on procedure symbol) and `ParameterMode` enum (`IN`, `OUT`, `INOUT`) exist.
   * Use `EntryType.PARAMETER` for parameter symbols.
2. **`RDParserExtended.py` - Declaration & Parameter Parsing:**

   * **Procedure Context Setup (on entering proc declaration parsing):**
     * `next_local_offset = -2`
     * `next_temp_offset = -2` (initialize, will decrease after locals)
     * `total_local_size = 0`
     * `parameter_info_list = []` # Store (name, token, type, mode)
   * **Parse Parameters (`parseArgs`):**
     * Populate `parameter_info_list` with declared mode.
     * **Offset Calculation (Post-Parsing):**
       * `next_param_offset = 4`
       * Iterate `parameter_info_list` **in reverse order**:
         * Get `name`, `token`, `type`, `mode`.
         * Determine `size` from `type`.
         * Create `param_symbol = Symbol(name, token, EntryType.PARAMETER, current_depth)`.
         * Set `param_symbol.offset = next_param_offset`, `param_symbol.size = size`.
         * Insert `param_symbol` into table.
         * Store `mode` in the *procedure's* symbol (`proc_symbol.param_modes[name] = mode`).
         * `next_param_offset += size`.
       * `total_param_size = next_param_offset - 4`. Store in `proc_symbol`.
   * **Parse Local Declarations (`parseDeclarativePart`):**
     * For each local `idt`:
       * Check for duplicates in current scope.
       * Determine `type` and `size`.
       * Create `local_symbol = Symbol(...)`.
       * Set `local_symbol.offset = next_local_offset`, `local_symbol.size = size`.
       * Insert `local_symbol`.
       * `next_local_offset -= size`.
       * `total_local_size += size`.
   * **Store Procedure Frame Info:** After locals/params, update `next_temp_offset = next_local_offset`. Store `total_local_size` and `total_param_size` in the procedure's symbol entry.

---



## Phase 2: TAC Generator Implementation (`TACGenerator.py`)

1. **Create `TACGenerator` Class:**
   * `__init__(self, output_filename)`: Open file.
   * `emit(self, instruction)`: Write instruction + newline.
   * `_newTempName(self)`: Generate `_tN`, increment counter.
   * `getPlace(self, symbol_or_value)`: Return string representation ("A", "_BP-4", "_t1", "5").
     * Handles constants, global vars (name), local/param vars (`_BP+/-offset`), temps (name).
   * `newTemp(self)`: Returns temporary name (`_tN`) generated by `_newTempName`. The parser decides if offset assignment is needed.
   * `emitBinaryOp(self, op, dest_place, left_place, right_place)`: Format and emit `dest = left op right`.
   * `emitUnaryOp(self, op, dest_place, operand_place)`: Format and emit `dest = op operand`.
   * `emitAssignment(self, dest_place, source_place)`: Format and emit `dest = source`.
   * `emitProcStart(self, proc_name)`: Emit `proc <name>`, reset temp counter.
   * `emitProcEnd(self, proc_name)`: Emit `endp <name>`.
   * `emitPush(self, place, mode)`: Emit `push <place>` or `push @<place>` based on mode.
   * `emitCall(self, proc_name)`: Emit `call <proc_name>`.
   * `emitProgramStart(self, main_proc_name)`: Emit `start <name>`.
   * `close(self)`: Close file.

## Phase 3: Parser Integration & Semantic Actions (`RDParserExtended.py`)

1. **Instantiation:** Pass a `TACGenerator` instance to the parser.
2. **Expression Parsing (`parseExpr`, `parseTerm`, `parseFactor`):**
   * **Return Value:** Functions return the **place** string where the result resides.
   * **`parseFactor`:**
     * `idt`: Lookup symbol. Get place via `tac_gen.getPlace()`. Return place.
     * `numt`: Return literal string.
     * `(` `Expr` `)`: Return place from inner `parseExpr`.
     * `not Factor`: Get operand place. `temp = tac_gen.newTemp()`. Emit unary op. Return `temp`.
     * `signopt Factor`: Get operand place. `temp = tac_gen.newTemp()`. Emit unary op (or `0 - op`). Return `temp`.
   * **Multiplicative Ops (`parseTerm`/`parseMoreFactor`):**
     * Get `left_place`.
     * Loop: Get `op`, get `right_place`. `temp = tac_gen.newTemp()`. Emit binary op. Update `left_place = temp`. Return final `left_place`.
   * **Additive Ops (`parseSimpleExpr`/`parseMoreTerm`):** Similar to multiplicative.
3. **Assignment (`parseAssignStat`):**
   * Get `dest_place` for LHS `idt` via `tac_gen.getPlace()`. Check if it's assignable (not constant).
   * Get `source_place` from `parseExpr`.
   * Call `tac_gen.emitAssignment(dest_place, source_place)`.
4. **Procedure Call (`parseProcCall`):**
   * Implement new grammar rules: `AssignStat -> idt := Expr | ProcCall`, `ProcCall -> idt ( Params )`, `Params`, `ParamsTail`.
   * Handle ambiguity (lookahead for `(` vs `:=`).
   * Lookup `idt` -> `proc_symbol`.
   * Parse `Params` -> get list of argument places.
   * Get formal parameter modes from `proc_symbol`.
   * Iterate args/modes: Call `tac_gen.emitPush(arg_place, mode)`.
   * Call `tac_gen.emitCall(proc_symbol.name)`.
5. **Procedure Boundaries:** Call `tac_gen.emitProcStart`/`emitProcEnd`.

## Phase 4: Driver & Testing (`JohnA7.py`)

1. **Modify Driver:**
   * Construct output filename.
   * Instantiate `TACGenerator`.
   * Pass `TACGenerator` to `RDParserExtended`.
   * Call `parser.parse()`.
   * Call `tac_generator.emitProgramStart(outermost_proc_name)` (get name from parser/symbol table).
   * Call `tac_generator.close()`.
2. **Testing:**
   * Use `test71.ada` to `test75.ada`.
   * Verify output against examples and requirements (offsets, names, calls, temps, directives).
