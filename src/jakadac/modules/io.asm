; io.asm
; Standard I/O routines for the Ada Compiler
; Author: John Akujobi
; Date: 2023-05-02
;
; This file contains standard I/O routines used by the
; assembly code generated by the Ada compiler.
;
; It includes the following procedures:
; - writestr: Write a string to stdout (expects OFFSET string in DX)
; - writeint: Write an integer to stdout (expects value in AX)
; - writeln:  Write a newline to stdout
; - readint:  Read an integer from stdin (returns value in BX)

; ------------------------------------------------------------
; writestr - Write a string to stdout
; Input:
;   DX = OFFSET of string (must be terminated with '$')
; Output:
;   None
; ------------------------------------------------------------
writestr PROC
    push ax         ; Save registers
    push dx
    
    mov ah, 09h     ; DOS function: print string
    int 21h         ; Call DOS
    
    pop dx          ; Restore registers
    pop ax
    ret
writestr ENDP

; ------------------------------------------------------------
; writeint - Write an integer to stdout
; Input:
;   AX = Integer to print
; Output:
;   None
; ------------------------------------------------------------
writeint PROC
    push ax         ; Save registers
    push bx
    push cx
    push dx
    push si
    
    mov si, ax      ; Save original number
    
    ; Handle negative numbers
    test ax, ax
    jge positive
    
    ; Number is negative
    push ax
    mov dl, '-'     ; Print minus sign
    mov ah, 02h
    int 21h
    pop ax
    neg ax          ; Make positive
    
positive:
    ; Set up for conversion
    mov cx, 0       ; Digit counter
    mov bx, 10      ; Divisor
    
divide_loop:
    mov dx, 0       ; Clear high word for division
    div bx          ; DX:AX / 10 = AX remainder DX
    push dx         ; Save remainder (digit)
    inc cx          ; Count digits
    test ax, ax     ; Any more digits?
    jnz divide_loop ; If yes, continue
    
print_loop:
    pop dx          ; Get digit
    add dl, '0'     ; Convert to ASCII
    mov ah, 02h     ; DOS function: print character
    int 21h         ; Call DOS
    loop print_loop ; Repeat for all digits
    
    pop si          ; Restore registers
    pop dx
    pop cx
    pop bx
    pop ax
    ret
writeint ENDP

; ------------------------------------------------------------
; writeln - Write a newline to stdout
; Input:
;   None
; Output:
;   None
; ------------------------------------------------------------
writeln PROC
    push ax         ; Save registers
    push dx
    
    mov ah, 02h     ; DOS function: print character
    mov dl, 0Dh     ; Carriage return
    int 21h
    mov dl, 0Ah     ; Line feed
    int 21h
    
    pop dx          ; Restore registers
    pop ax
    ret
writeln ENDP

; ------------------------------------------------------------
; readint - Read an integer from stdin
; Input:
;   None
; Output:
;   BX = Integer read
; ------------------------------------------------------------
readint PROC
    push ax         ; Save registers
    push cx
    push dx
    push si
    push di
    
    ; Initialize
    mov cx, 0       ; Character count
    mov di, 0       ; Sign flag (0 = positive)
    mov si, 0       ; Buffer to hold input chars
    
read_char:
    mov ah, 01h     ; DOS function: read character with echo
    int 21h         ; Call DOS, character in AL
    
    ; Check for end of input
    cmp al, 0Dh     ; Carriage return?
    je convert_to_int
    
    ; Check for sign at beginning
    cmp cx, 0
    jne not_sign
    cmp al, '-'
    jne not_sign
    
    ; It's a minus sign
    mov di, 1       ; Set sign flag
    jmp next_char
    
not_sign:
    ; Check if it's a digit
    cmp al, '0'
    jb invalid_char
    cmp al, '9'
    ja invalid_char
    
    ; It's a digit, add to buffer
    sub al, '0'     ; Convert ASCII to value
    mov bx, 10
    mov dx, si      ; Previous value
    mul bx          ; DX:AX = BX * AX
    add si, ax      ; Add new digit
    
next_char:
    inc cx          ; Count character
    cmp cx, 6       ; Max 5 digits + sign
    jb read_char
    
convert_to_int:
    ; Check sign flag
    mov bx, si      ; Move result to BX
    cmp di, 1       ; Negative?
    jne done
    neg bx          ; Make negative
    
done:
    pop di          ; Restore registers
    pop si
    pop dx
    pop cx
    pop ax
    ret
    
invalid_char:
    ; Invalid character, try again
    jmp read_char
readint ENDP
