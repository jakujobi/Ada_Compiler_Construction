#!/usr/bin/env python3
# tac_instruction.py
# Author: AI Assistant
# Date: 2024-05-04
# Version: 1.0
"""
Dataclass to represent a single Three Address Code instruction.
Provides a structured way to access opcode and operands.
"""

from dataclasses import dataclass, field
from typing import Optional, Tuple, Union, List
import logging

# Configure logger for this module
logger = logging.getLogger(__name__)
# Basic configuration if run standalone or not configured elsewhere
if not logger.handlers:
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# Define common TAC operators/opcodes if needed as constants or Enum
# Example:
# class TacOpcode(Enum):
#     ASSIGN = '='
#     ADD = '+'
#     # ... etc

@dataclass
class TACInstruction:
    """Represents a single TAC instruction parsed from a tuple."""
    opcode: str = field(default="ERROR")
    dest: Optional[str] = field(default=None)
    op1: Optional[str] = field(default=None)
    op2: Optional[str] = field(default=None)
    # op3: Optional[str] = field(default=None) # If needed for complex ops
    original_tuple: Optional[Tuple] = field(default=None, repr=False) # Store original for debugging

    @classmethod
    def from_tuple(cls, tac_tuple: Tuple) -> 'TACInstruction':
        """
        Factory method to create a TACInstruction from a tuple generated by TACGenerator.

        Handles different tuple formats based on the presumed opcode.
        Expected formats:
            ('=', dest, source)          -> Assignment
            ('=', dest, op, operand)    -> Unary operation
            (op, dest, op1, op2)        -> Binary operation (+, -, *, /, etc.)
            ('proc', name)
            ('endp', name)
            ('push', place)
            ('call', name)
            ('rdi', place)
            ('wri', place)
            ('wrs', label)
            ('wrln',)
            ('START PROC', name)
            # Potentially others: label, goto, ifgoto, etc.
        """
        if not isinstance(tac_tuple, tuple) or not tac_tuple:
            logger.error(f"Invalid input: Expected non-empty tuple, got {tac_tuple}")
            return cls(opcode="ERROR_INVALID_INPUT", original_tuple=tac_tuple)

        op = str(tac_tuple[0]).lower() # Normalize opcode
        args = tac_tuple[1:]
        instr = cls(opcode=op, original_tuple=tac_tuple) # Initialize with opcode

        try:
            if op == '=':
                if len(args) == 2: # Assignment: (=, dest, src)
                    instr.dest = str(args[0])
                    instr.op1 = str(args[1])
                elif len(args) == 3: # Unary Op: (=, dest, unary_op, src)
                    instr.dest = str(args[0])
                    instr.opcode = str(args[1]).lower() # Actual operator is the second element
                    instr.op1 = str(args[2])
                else:
                    raise ValueError(f"Invalid assignment/unary format: {tac_tuple}")
            elif op in ('+', '-', '*', '/', 'mod', 'rem', 'and', 'or'): # Binary Op: (op, dest, op1, op2)
                if len(args) == 3:
                    instr.dest = str(args[0])
                    instr.op1 = str(args[1])
                    instr.op2 = str(args[2])
                else:
                     raise ValueError(f"Invalid binary operation format: {tac_tuple}")
            elif op in ('proc', 'endp', 'push', 'call', 'rdi', 'wri', 'wrs'): # Single operand instructions
                if len(args) == 1:
                    instr.op1 = str(args[0]) # Use op1 for the single argument/target
                else:
                    raise ValueError(f"Invalid single operand instruction format: {tac_tuple}")
            elif op == 'wrln': # Zero operand instruction
                if len(args) == 0:
                    pass # No operands needed
                else:
                    raise ValueError(f"Invalid wrln format: {tac_tuple}")
            elif op == 'start proc': # Special case like proc/call
                instr.opcode = "start_proc" # Normalize
                if len(args) == 1:
                    instr.op1 = str(args[0]) # Use op1 for the procedure name
                else:
                    raise ValueError(f"Invalid start proc format: {tac_tuple}")
            # Add cases for labels, jumps, etc. if they are tuples
            # elif op == 'label': instr.op1 = str(args[0]) ...
            else:
                 # Assume it might be a simple opcode + args format if unrecognized
                 logger.warning(f"Unrecognized TAC opcode '{op}' in tuple: {tac_tuple}. Assigning args sequentially.")
                 if len(args) > 0: instr.op1 = str(args[0])
                 if len(args) > 1: instr.op2 = str(args[1])
                 # if len(args) > 2: instr.op3 = str(args[2]) # If op3 exists

        except (IndexError, ValueError) as e:
             logger.error(f"Error parsing TAC tuple {tac_tuple}: {e}")
             # Return instruction with original opcode but potentially no operands parsed
             instr.opcode = f"ERROR_PARSING_{op}"

        return instr

    def __str__(self) -> str:
        # Simple string representation, can be enhanced
        parts = [self.opcode]
        if self.dest: parts.append(f"dest={self.dest}")
        if self.op1: parts.append(f"op1={self.op1}")
        if self.op2: parts.append(f"op2={self.op2}")
        # if self.op3: parts.append(f"op3={self.op3}")
        return f"TACInstruction({', '.join(parts)})"; 